;;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Author      : Dan Bothell
;;; Copyright   : (c) 2004 Dan Bothell
;;; Availability: Covered by the GNU LGPL, see LGPL.txt
;;; Address     : Department of Psychology 
;;;             : Carnegie Mellon University
;;;             : Pittsburgh, PA 15213-3890
;;;             : db30@andrew.cmu.edu
;;; 
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Filename    : scheduling.lisp
;;; Version     : 1.5
;;; 
;;; Description : Event creation and scheduling and schedule running functions.
;;; 
;;; Bugs        : [X] Need to fix/remove the update functions from the modules
;;;             :     because how they get called prevents one from scheduleing
;;;             :     events correctly during one (in particular the device 
;;;             :     device-update-attended-loc doesn't accept the time parameters
;;;             :     but just adding that is really just a hack).
;;;             : [ ] There isn't a way to delete an "after" event that was waiting
;;;             :     but then got scheduled since it's no longer the same event
;;;             :     in the queue.
;;;
;;; To do       : [ ] Finish documentation.
;;;             : [x] Add an equivalent to the real-time-slack-hook-fn in rpm.
;;;             : [ ] Consider a global randomize time flag and/or parameter to the
;;;             :     scheduling functions.
;;;             : [x] The break events and "stopping reason" trace don't go to
;;;             :     the output of all models but probably should so that if
;;;             :     the traces are split at the model level they all show it.
;;;             : [x] Run-full-time and run-until-time both still rely on the
;;;             :     time count in seconds to determine the "end" but that's
;;;             :     still got potential problems.

;;; 
;;; ----- History -----
;;;
;;; 2004.08.16 Dan
;;;             : Creation
;;; 2004.12.06 Dan
;;;             : Updated a warning message because I found it uninformative.
;;;             : Tried to fit things to 80 char line width.
;;; 2005.01.12 Dan
;;;             : Because the device is now a module it doesn't need to
;;;             : be handled specially in set-mp-clock.
;;; 2005.01.27 Dan
;;;             : * Modified run-one-event to use filter-output-events which
;;;             :   is now part of the printing module to determine if the
;;;             :   trace should be displayed.
;;; 2005.02.03 Dan
;;;             : * Removed the format call from the periodic action's details.
;;; 2005.02.14 Dan
;;;             : * Added the run-until-condition function.
;;; 2005.02.16 Dan
;;;             : * Some general cleanup and added the "stopping reason" output
;;;             :   to the run functions.
;;; 2005.02.22 Dan
;;;             : * Cleaned up the stopping reason output.
;;;             : * Fixed a bug in run-full-time by just making it use
;;;             :   run-until-time.
;;; 2005.02.25 Dan
;;;             : * Made run work more like pm-run in that if there are future
;;;             :   events it will work like run-full-time instead of just
;;;             :   stopping.
;;; 2005.02.28 Dan
;;;             : * Switched the stopping reason output from model-output to
;;;             :   meta-p-output (which I've put back into things) because
;;;             :   model-output doesn't work in a multi-model situation.
;;; 2005.04.20 Dan
;;;             : * Changed add-pre/post-event-hook so that fboundp doesn't
;;;             :   cause problems for Lispworks with lambdas.
;;; 2005.05.20 Dan
;;;             : * Fixed a bug in run-until-time (caused primarily when
;;;             :   run-full-time used) where a non-rounded time could cause
;;;             :   the system to get stuck.
;;; 2005.12.08 Dan
;;;             : * Fixed a bug in the output of the events generated by
;;;             :   schedule-periodic-event and periodic-action.
;;; 2006.01.25 Dan
;;;             : * Modifying all the "run" functions so that when they end 
;;;             :   a "run-terminated" event is passed to all the models if
;;;             :   it terminates other than due to a break.  This way, the
;;;             :   event hooks can detect when a run ends (either a break
;;;             :   event or an event with the run-terminated action) which
;;;             :   makes adding additional tracing and other tools easier.
;;; 2006.01.26 Dan
;;;             : * Added an optional parameter to the add-pre/post-event-hook
;;;             :   functions to suppress the warning if one adds a hook that's
;;;             :   already on the list.  It just returns nil in that case now.
;;;             :   This helps because the hook is at the meta-process level,
;;;             :   but one may have a module (at the model level) that needs
;;;             :   to add such a hook and not want to see the warning if there
;;;             :   are multiple models loaded and using it.
;;; 2006.01.30 Dan
;;;             : * Changed the run-terminated event to a maintenance event.
;;;             : * Added the keyword param :include-maintenance to the schedule-
;;;             :   after-* functions which indicates whether or not to include
;;;             :   maintenance events in those that can trigger it (it defaults
;;;             :   to nil).  This keeps things from getting scheduled after 
;;;             :   events that don't do anything for the model.
;;;             : * Added the schedule-maintenance-event-relative function to
;;;             :   be able to schedule maintenance events.  Could make it a
;;;             :   switch on the existing functions, but for now at least
;;;             :   I've decided to use a different function.
;;; 2006.02.24 Dan
;;;             : * Fixed a bug in run-until-time that caused it to not work
;;;             :   if there was more than one model defined.
;;; 2006.02.27 Dan [1.2]
;;;             : * Modified run-schd-queue and set-mp-clock so that they
;;;             :   now use the "real time" control functions that can be set
;;;             :   for the meta-process using mp-real-time-management.
;;; 2006.02.28 Dan
;;;             : * Added a schedule-maintenance-event function and changed
;;;             :   run-until-time to actually use it.
;;; 2006.03.03 Dan
;;;             : * Modified run-sched-queue to use the max-delta-time 
;;;             :   property set with mp-real-time-management.
;;;             :   New (non-maintenance) "dummy" events will be automatically 
;;;             :   generated to occur in any time slice that needs them. 
;;; 2006.03.08 Dan
;;;             : * Fixed a bug with schedule-break-after-module because it
;;;             :   didn't set the model for the event, so never matched up
;;;             :   with a new event to get scheduled.
;;;
;;; 2006.05.02 Dan
;;;             : * Noted an issue with the update function of modules and put
;;;             :   it under bugs above.
;;; 2006.07.13 Dan
;;;             : * Fixed a bug with run-until-time that caused it to jump
;;;             :   back in time if the end-time had already passed.
;;; 2006.07.14 Dan
;;;             : * Added another output to run-n-events to make it clearer
;;;             :   in the trace why it stopped - differentiate hitting the
;;;             :   event-count from just running out of events.
;;; 2006.07.18 Dan
;;;             : * Removed the schedule-maintenance-* functions and
;;;             :   replaced them with a keyword :maintenance t/nil
;;;             :   in the regular schedule-* functions.
;;;             : * Updated all references to schedule-maintenance-* with
;;;             :   the correct schedule-* function.
;;;             : * As a saftey check those maintenance functions now just
;;;             :   print a warning to let people know there was a change.
;;; 2006.07.20 Dan
;;;             : * Fixed a bug in schedule-periodic-event because it tried
;;;             :   to take the symbol-name of an interpreted function if that
;;;             :   was passed as the action.
;;;             : * Updated conditions-met because a break event doesn't have
;;;             :   a model so if it's waiting it'll never match to any specific
;;;             :   model so should instead match to any model.
;;;             : * Fixed update waiting-events because it didn't distinguish
;;;             :   between break events and normal events which caused a
;;;             :   problem for schedule-break-after-module.
;;; 2006.07.28 Dan
;;;             : * Fixed the warning in delete-event-hook.
;;; 2007.01.19 Dan
;;;             : * Fixed a bug in periodic-action because it had the same 
;;;             :   symbol-name issue as schedule-periodic-event did...
;;; 2007.04.16 Dan
;;;             : * Updated the version to 1.3.
;;;             : * Made the run-terminated action actually do something.  It
;;;             :   checks the :ncnar parameter and if true calls normalize-
;;;             :   chunk-names.  
;;; 2007.05.04 Dan
;;;             : * Added a general method for delete-event (specified the class
;;;             :   t) so that it doesn't throw an error if a bad value is
;;;             :   provided.
;;; 2007.07.13 Dan
;;;             : * Changed run-terminated so that when :ncnar is set to delete
;;;             :   it actually forces the chunk deletion and name uninterning.
;;; 2007.08.28 Dan
;;;             : * Added s and w options to run-step to show the event queue and
;;;             :   the waiting events during the stepping.
;;; 2007.10.31 Dan
;;;             : * Fixed a bug with the printing of break events in run-one-event -
;;;             :   if there was more than one model the event wasn't being output.
;;;             :   Now check for break events and use meta-p-output instead of 
;;;             :   model-output since a break doesn't have a model.
;;;             : * Changed the model name used for the terminating event output
;;;             :   to just '- so that it will always line up even if the longest
;;;             :   model name is only 1 character.
;;; 2007.11.30 Dan
;;;             : * Changed run-terminated to use awhen so it doesn't have to
;;;             :   call sgp twice (an expensive call).
;;; 2007.12.13 Dan
;;;             : * Fixed a bug in schedule-periodic-event because if it was
;;;             :   passed an action that wasn't a symbol the call to fboundp
;;;             :   for the details would break.
;;; 2008.05.02 Dan
;;;             : * Added another option to run-step (b) for showing the buffer
;;;             :   contents.
;;; 2008.10.23 Dan
;;;             : * Updated run-terminated to use the new flags for normalizing.
;;; 2008.10.28 Dan
;;;             : * Changed the model-output in run-one-event so that the 
;;;             :   event string isn't directly used as the format string to
;;;             :   avoid issues with tildes in the output.
;;; 2009.03.10 Dan [1.4]
;;;             : * Moved the code to check for sending module "updates" from
;;;             :   set-mp-clock to run-sched-queue.  This has two effects:
;;;             :   - Updates occur at the end of a time step now and not the
;;;             :     "top of the next one".
;;;             :   - It's safe to schedule events during an "update" (fixes
;;;             :     the bug listed under bugs).
;;; 2009.04.29 Dan
;;;             : * Added checks for recursive calls to run and now signal a
;;;             :   warning and just abort the later calls.
;;; 2009.12.04 Dan [1.5]
;;;             : * Updated the real-time running code to allow for a little
;;;             :   more responsiveness when a slack-hook is provided.  Events
;;;             :   can be scheduled during the slack-hook and they can jump
;;;             :   "back" in time if desired (which would require explicitly
;;;             :   scheduling them for that time since "now" has still already 
;;;             :   moved) which likely requires a custom clock as well (to
;;;             :   know when "now" is relative to where the event queue is).
;;;             : * In addition to that, if the allow-dynamics is also provided 
;;;             :   then events which were scheduled using one of the after
;;;             :   scheduling functions and are flagged as dynamic will be 
;;;             :   sensitive to those new events (or events that they schedule)
;;;             :   and may be moved back in time if appropriate (conflict-resolution 
;;;             :   is now scheduled as dynamic so it could move back).
;;;             : * It is important to note however that the scheduling code is
;;;             :   still not thread safe -- any asynchronous event scheduling
;;;             :   should occur in the slack-hook (or some other safe place) and 
;;;             :   be protected appropriately.
;;; 2010.09.02 Dan
;;;             : * Added a test to run-sched-queue to check if the end time is
;;;             :   greater than what can be represented accurately with the 
;;;             :   current floating point size of the time and warn if it should
;;;             :   be changed or there's nothing that can be done.
;;;             : * Changed the calls that set the time so that they go through
;;;             :   the proper coercion when things are changed.
;;; 2010.11.03 Dan
;;;             : * Changed all of the code to use time in milliseconds internally 
;;;             :   and convert to/from seconds where there's an interface with the
;;;             :   user since the API is for seconds.
;;;             : * Removed the floating point time check code since it's not 
;;;             :   necessary now, but may still be useful to know if the time
;;;             :   is "too big" in the future so still leaving it in comments
;;;             :   for potentially enabling again in the future.
;;; 2010.12.22 Dan
;;;             : * Took the toggle out of the run-sched-queue since the integer
;;;             :   time values won't have the same issues as floating point 
;;;             :   math and comparisons.
;;;             : * Added code to notify modules at the start of a run for all
;;;             :   the modules which have a run-notify function.
;;; 2011.01.11 Dan
;;;             : * Added code to notify modules at the end of a run too, and 
;;;             :   reorganized run-sched-queue a little to make sure the 
;;;             :   unwind-protect covers everything.
;;; 2011.01.14 Dan
;;;             : * Added the new command mp-running? to query whether the current
;;;             :   meta-process is currently running.
;;; 2011.02.04 Dan
;;;             : * Added visicon and buffer-status options to run-step.
;;; 2011.03.25 Dan
;;;             : * Took the API section out since it's out of date and I don't
;;;             :   want to update it with the new changes either...
;;;             : * Adjusted run-one-event so that dynamics clear their dynamic
;;;             :   flag before being output in the trace.
;;; 2011.03.29 Dan
;;;             : * Added the option of specifying time in milliseconds for all
;;;             :   of the scheduling commmands by specifying :time-in-ms t.
;;; 2011.04.25 Dan
;;;             : * Fixed a bug in schedule-event-relative introduced with the
;;;             :   :time-in-ms option.
;;;             : * Schedule-periodic-event and schedule-break-relative had the
;;;             :   same issue.
;;; 2011.04.28 Dan
;;;             : * Changed the schedule-maintenance-event* functions which aren't
;;;             :   used to avoid warnings at compile time.
;;;             : * Added some declaims to avoid compiler warnings about 
;;;             :   undefined functions.
;;; 2011.05.18 Dan 
;;;             : * Changed set-mp-clock and insert-queue-event to prevent time
;;;             :   from moving backwards.  The slack-hook for real time now
;;;             :   gets called with a second parameter which is the "next"
;;;             :   time in milliseconds.
;;; 2011.05.19 Dan
;;;             : * Added a declare to ignore next-time in real-time-slack.
;;; 2011.06.06 Dan
;;;             : * Changed the second parameter for the slack-hook to time in
;;;             :   seconds since all the "user" code should be working in seconds.
;;; 2011.06.07 Dan
;;;             : * Changed the real-time clock setting so that the real-time
;;;             :   clock function is called before the model time is checked 
;;;             :   so that a custom clock could schedule events that are "ahead"
;;;             :   of the next model event.
;;; 2012.01.27 Dan
;;;             : * Added an additional test to the scheduling functions so that
;;;             :   they reject actions which are macros since those will throw
;;;             :   an error at run time.
;;; 2012.08.08 Dan
;;;             : * Send all the notifications (start, stop, update, terminate)
;;;             :   to the models in order using meta-p-model-order instead of
;;;             :   maphashing over the model table for consistency.
;;; 2012.12.06 Dan
;;;             : * Changed run-sched-queue so that it returns the time in ms
;;;             :   and then convert that as needed in the "run" functions to
;;;             :   try and avoid other float issues with math on times.
;;; 2013.01.03 Dan
;;;             : * Use the meta-p-max-time-maintenance value when scheduling a
;;;             :   necessary time-delta event.
;;; 2013.01.04 Dan
;;;             : * Add cannot-define-model to run-sched-queue and send-run-terminated-events 
;;;             :   to avoid problems.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General Docs:
;;; 
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Public API:
;;;
;;;
;;; See reference-manual...
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Design Choices:
;;; 
;;; Keep the system as simple as I can.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; The code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+:packaged-actr (in-package :act-r)
#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)
#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)

(declaim (ftype (function () t) print-visicon))
(declaim (ftype (function () t) delete-chunks-after-run))
(declaim (ftype (function () t) update-chunks-at-all))
(declaim (ftype (function (t) t) filter-output-events))

(defvar *periodic-event-id-counter* 0)

(defun mp-running? ()
  (awhen (current-mp)
         (meta-p-running it)))

(defun run-sched-queue (mp stop-condition &key (real-time nil))
  "The internal function that steps through events sending them to be
    executed until a condtion is met"
  
  (cannot-define-model
   (unwind-protect 
       (let ((event-count 0)
             (last-update-time -1)) 
         
         (setf (meta-p-running mp) t)
         
         ;; Notify any modules which care that a new run has begun
         
         (let ((current-model (meta-p-current-model mp)))
           (unwind-protect 
               (dolist (model-name (meta-p-model-order mp))
                 (let ((model (gethash model-name (meta-p-models mp))))
                   (setf (meta-p-current-model mp) model) 
                   (dolist (module (run-notify-modules))
                     (run-notify-module module))))
             
             (setf (meta-p-current-model mp) current-model)))
         
         (setf (meta-p-start-time mp) (meta-p-time mp))
         (setf (meta-p-start-real-time mp) 
           (funcall (meta-p-time-function mp)))
         
         (setf (meta-p-break mp) nil)
         
         (while (and (not (meta-p-break mp))
                     (meta-p-events mp)
                     (not (funcall stop-condition 
                                   mp 
                                   (evt-mstime (first (meta-p-events mp)))
                                   event-count)))           
           
           
           
           (if (and 
                (meta-p-max-time-delta mp)
                (numberp (meta-p-max-time-delta mp))
                (> (- (evt-mstime (first (meta-p-events mp))) (meta-p-time mp))
                   (meta-p-max-time-delta mp)))
               
               (progn
                 
                 (dolist (model (mp-models))
                   (with-model-eval model
                     (schedule-event-relative (meta-p-max-time-delta mp) 'dummy-event-function 
                                              :priority :max 
                                              :details 
                                              "A dummy event to prevent model skip ahead"
                                              :output nil
                                              :time-in-ms t
                                              :maintenance (meta-p-max-time-maintenance mp)))))
             (progn
               
               (run-one-event mp real-time)
               
               (incf event-count)
               
               ;; Check to see if there needs to be an update 
               
               (unless (or (and (meta-p-events mp)
                                (= (meta-p-time mp) (evt-mstime (first (meta-p-events mp)))))
                           (= (meta-p-time mp) last-update-time))
                 
                 (let ((current-model (meta-p-current-model mp)))
                   (unwind-protect 
                       (dolist (model-name (meta-p-model-order mp))
                         (let ((model (gethash model-name (meta-p-models mp))))
                           (setf (meta-p-current-model mp) model) 
                           (dolist (module (updating-modules))
                             (update-the-module module (ms->seconds last-update-time) (ms->seconds (meta-p-time mp))))))
                     
                     (setf (meta-p-current-model mp) current-model)))
                 
                 (setf last-update-time (meta-p-time mp))))))
         
         (setf (meta-p-events mp) (remove 'dummy-event-function (meta-p-events mp) :key #'evt-action))
         
         (values (- (meta-p-time mp) (meta-p-start-time mp)) event-count (meta-p-break mp)))
    
     (progn
       (setf (meta-p-running mp) nil)
       ;; Notify any modules which care that a run has ended
       
       (let ((current-model (meta-p-current-model mp)))
         (unwind-protect 
             (dolist (model-name (meta-p-model-order mp))
               (let ((model (gethash model-name (meta-p-models mp))))
                 (setf (meta-p-current-model mp) model) 
                 (dolist (module (run-over-notify-modules))
                   (run-over-notify-module module))))
          
           (setf (meta-p-current-model mp) current-model)))))))

    
;;; run-one-event 
;;;
;;; This function takes one required parameter which is a meta-process (not
;;; a name of a meta-process).
;;;
;;; The clock is updated, the next event on the meta-process's scheduled events 
;;; queue is removed,  a line is printed to the trace to indicate the event,
;;; and that event's action is executed with  the current model set to the model
;;; specified in that event (even if it doesn't name a model).  If there are 
;;; any event hook functions, they are called with the event as a parameter 
;;; as appropriate (a pre-hook is called before the action and a post-hook is 
;;; called after the action).

(defun run-one-event (mp &optional (real-time nil))
  "Dispatch the next event on the meta-process's schedule"
  (let ((current-model (meta-p-current-model mp)))
    (unwind-protect 
        (let ((next-event nil))
          (set-mp-clock mp (evt-mstime (car (meta-p-events mp))) real-time)
          
          (setf next-event (pop (meta-p-events mp)))
          
          (when (evt-dynamic next-event)
            (setf (meta-p-dynamics mp) (remove next-event (meta-p-dynamics mp) :key #'car))
            (setf (evt-wait-condition next-event) nil)
            (setf (evt-dynamic next-event) nil))
          
          (when (evt-model next-event)
            (setf (meta-p-current-model mp) 
              (gethash (evt-model next-event) (meta-p-models mp))))
          
          (dolist (hook (meta-p-pre-events mp))
            (funcall hook next-event))
          
          (when (and (evt-output next-event) 
                     (filter-output-events next-event))
            
            (if (act-r-break-event-p next-event)
                (meta-p-output (format-event next-event))
              (model-output "~a" (format-event next-event))))
          
          (if (evt-destination next-event)
              (apply (evt-action next-event) 
                     (append (list (get-module-fct
                                    (evt-destination next-event))) 
                             (evt-params next-event)))
            (apply (evt-action next-event) (evt-params next-event)))
          
          (dolist (hook (meta-p-post-events mp))
            (funcall hook next-event)))
      
      (setf (meta-p-current-model mp) current-model))))

;;; set-mp-clock
;;;
;;; This function takes three parameters which are a meta-process, the next
;;; time as it stands now, and whether or not it's to run in real-time.
;;;
;;; The meta-process's time is updated to the specified time and then if the
;;; meta-process's mp-real-time-p slot is non-nil it spins until the appropriate 
;;; amount of time has passed.
;;;
;;; The spin should probably call sleep, or perhaps a machine specific 
;;; event handler so that it could be swapped out and doesn't swamp the
;;; processor because that could be an issue for multiple models in a real time
;;; environment.

(defun set-mp-clock (mp time real-time)
  "Update the time of a meta-process and maybe spin for the necessary real time"
  
  (if real-time
    (progn
    
      (do* ((current-real-time (funcall (meta-p-time-function mp))
                               (funcall (meta-p-time-function mp)))
            (delta-model (- (evt-mstime (car (meta-p-events mp))) (meta-p-start-time mp))
                         (- (evt-mstime (car (meta-p-events mp))) (meta-p-start-time mp)))
            (delta-real (seconds->ms (/ (- current-real-time (meta-p-start-real-time mp))
                                        (meta-p-units-per-second mp)))
                        (seconds->ms (/ (- current-real-time (meta-p-start-real-time mp))
                                        (meta-p-units-per-second mp)))))
           ((>= delta-real delta-model))
        (funcall (meta-p-slack-function mp) (ms->seconds (- delta-model delta-real)) (evt-time (car (meta-p-events mp)))))
      
      (setf (meta-p-time mp) (evt-mstime (car (meta-p-events mp)))))
    (setf (meta-p-time mp) time)))
  

(defun real-time-slack (delta next-time)
  (declare (ignore next-time))
  (when (> delta .150)
    (sleep delta)))


;;; This function lets all the models know that a run has terminated.

(defun send-run-terminated-events (mp)
  (cannot-define-model
   (let ((current-model (meta-p-current-model mp)))
     (unwind-protect 
         (dolist (model-name (meta-p-model-order mp))
           (push (make-act-r-maintenance-event :mstime (meta-p-time (current-mp))
                                               :priority :max
                                               :action 'run-terminated
                                               :params nil
                                               :model model-name
                                               :mp (current-meta-process)
                                               :output nil)
                 (meta-p-events mp))
           (run-one-event mp))
       
       (setf (meta-p-current-model mp) current-model)))))

(defun run-terminated ()
  (when (update-chunks-at-all)
    (normalize-chunk-names (delete-chunks-after-run)))
  nil)



(defun run (run-time &key (real-time nil))
  (verify-current-mp  
   "run called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (and (numberp run-time) (> run-time 0)))
         (print-warning "run-time must be a number greater than zero.")
       (let ((ms-time (seconds->ms run-time)))
         (flet ((test (mp next-time count)
                    (declare (ignore count))
                    (> (- next-time (meta-p-start-time mp)) ms-time)))
         (multiple-value-bind (time events break)
             (run-sched-queue (current-mp) #'test :real-time real-time)
           (unless break
             (send-run-terminated-events (current-mp))
             (if (< time ms-time)
                 (if (null (meta-p-events (current-mp)))
                     (meta-p-output (format-event (make-act-r-event 
                                                   :mstime (meta-p-time (current-mp))
                                                   :module "------"
                                                   :model '-
                                                   :details 
                                                   "Stopped because no events left to process"
                                                   :output t
                                                   :mp (current-meta-process))))
                   (progn
                     (run-full-time (- run-time (ms->seconds time)) :real-time nil)
                     (setf time ms-time)))
               (meta-p-output (format-event (make-act-r-event 
                                             :mstime (meta-p-time (current-mp))
                                             :module "------"
                                             :model '-
                                             :details "Stopped because time limit reached"
                                             :output t
                                             :mp (current-meta-process))))))
           (values (ms->seconds time) events break))))))))

(defun run-until-condition (condition &key (real-time nil))
  (verify-current-mp  
   "run-until-condition called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (or (functionp condition) (fboundp condition)))
         (print-warning "condition must be a function.")
       (multiple-value-bind (time events break)
           (run-sched-queue (current-mp) 
                            #'(lambda (mp next-time count)
                                (declare (ignore mp next-time count))
                                (funcall condition))
                            :real-time real-time)
         (unless break
           (send-run-terminated-events (current-mp))
           (if (null (meta-p-events (current-mp)))
               (meta-p-output (format-event (make-act-r-event 
                                             :mstime (meta-p-time (current-mp))
                                             :module "------"
                                             :model '-
                                             :details "Stopped because no events to process"
                                             :output t
                                             :mp (current-meta-process))))
             (meta-p-output (format-event (make-act-r-event 
                                           :mstime (meta-p-time (current-mp))
                                           :module "------"
                                           :model '-
                                           :details "Stopped because condition is true"
                                           :output t
                                           :mp (current-meta-process))))))
         (values (ms->seconds time) events break))))))

(defun run-full-time (run-time &key (real-time nil))
  (verify-current-mp  
   "run-full-time called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (and (numberp run-time) (> run-time 0)))
         (print-warning "run-time must be a number greater than zero.")
       
       (let ((msend-time (+ (seconds->ms run-time) (meta-p-time (current-mp)))))
         (flet ((test (mp next-time count)
                      (declare (ignore count) (ignore mp))
                      (> next-time msend-time)))
           
           (if (current-model)
               (schedule-event msend-time 'dummy-event-function 
                               :maintenance t :priority :min 
                               :details "A dummy event to guarantee a run until time"
                               :time-in-ms t
                               :output nil)
             (with-model-eval (first (mp-models)) ;; just pick the first one
               (schedule-event msend-time 'dummy-event-function 
                               :maintenance t 
                               :priority :min 
                               :details "A dummy event to guarantee a run until time"
                               :time-in-ms t
                               :output nil)))
           
           (multiple-value-bind (time events break)
               (run-sched-queue (current-mp) #'test :real-time real-time)
             (unless break
               (send-run-terminated-events (current-mp))
               (meta-p-output (format-event (make-act-r-event 
                                             :mstime (meta-p-time (current-mp))
                                             :module "------"
                                             :model '-
                                             :details "Stopped because time limit reached"
                                             :output t
                                             :mp (current-meta-process)))))
             (values (ms->seconds time) events break))))))))

(defun dummy-event-function ())

(defun run-until-time (end-time &key (real-time nil))
  (verify-current-mp  
   "run-until-time called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (and (numberp end-time) (> end-time 0)))
         (print-warning "end-time must be a number greater than zero.")
       (let ((ms-end-time (seconds->ms end-time)))
         
         (if (<= ms-end-time (meta-p-time (current-mp)))
             (progn
               (meta-p-output (format-event (make-act-r-event 
                                             :mstime (meta-p-time (current-mp))
                                             :module "------"
                                             :model '-
                                             :details "Stopped because end time already passed"
                                             :output t
                                             :mp (current-meta-process))))
               (values 0 0 nil))
           (flet ((test (mp next-time count)
                        (declare (ignore count) (ignore mp))
                        (> next-time ms-end-time)))
             
             (if (current-model)
                 (schedule-event ms-end-time 'dummy-event-function 
                                 :maintenance t :priority :min 
                                 :details "A dummy event to guarantee a run until time"
                                 :time-in-ms t
                                 :output nil)
               (with-model-eval (first (mp-models)) ;; just pick the first one
                 (schedule-event end-time 'dummy-event-function 
                                 :maintenance t 
                                 :priority :min 
                                 :details "A dummy event to guarantee a run until time"
                                 :time-in-ms t
                                 :output nil)))
             
             (multiple-value-bind (time events break)
                 (run-sched-queue (current-mp) #'test :real-time real-time)
               (unless break
                 (send-run-terminated-events (current-mp))
                 (meta-p-output (format-event (make-act-r-event 
                                               :mstime (meta-p-time (current-mp))
                                               :module "------"
                                               :model '-
                                               :details "Stopped because time limit reached"
                                               :output t
                                               :mp (current-meta-process)))))
               (values (ms->seconds time) events break)))))))))


(defun run-n-events (event-count &key (real-time nil))
  (verify-current-mp  
   "run-n-events called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (if (not (and (numberp event-count) (> event-count 0)))
         (print-warning "event-count must be a number greater than zero.")
       (flet ((test (mp next-time count)
                    (declare (ignore next-time) (ignore mp))
                    (= count event-count)))
         (multiple-value-bind (time events break)
             (run-sched-queue (current-mp) #'test :real-time real-time)
           (unless break
             (send-run-terminated-events (current-mp))
             
             (if (< events event-count)
                 (meta-p-output (format-event (make-act-r-event 
                                               :mstime (meta-p-time (current-mp))
                                               :module "------"
                                               :model '-
                                               :details "Stopped because no events to process"
                                               :output t
                                               :mp (current-meta-process))))   
               (meta-p-output (format-event (make-act-r-event 
                                             :mstime (meta-p-time (current-mp))
                                             :module "------"
                                             :model '-
                                             :details "Stopped because event limit reached"
                                             :output t
                                             :mp (current-meta-process))))))
           (values (ms->seconds time) events break)))))))




(defun run-step ()
  (verify-current-mp  
   "run-step called with no current meta-process."
   (if (meta-p-running (current-mp))
       (print-warning "Recursive call to a running function not allowed.  Must wait for a 'run' to complete before 'running' again.")
     (flet ((test (mp next-time count)
                  (declare (ignore next-time count))
                  (loop
                    (when (null (meta-p-events mp))
                      (format t "No more events to process")
                      (return t))
                    (format t "Next Event: ~A~%" 
                      (format-event (car (meta-p-events mp))))
                    (format t "[A]bort (or [q]uit)~%")
                    (format t "[D]elete~%")
                    (format t "[S]how event queue~%")
                    (format t "[W]aiting events~%")
                    (format t "[B]uffer contents~%")
                    (format t "[V]isicon~%")
                    (format t "[R]eport buffer status~%")
                    (format t "[E]xecute~%")
                    
                    (let ((response (read )))
                      (case response
                        ((a q) (return t))
                        (e (return nil))
                        (s (mp-show-queue))
                        (w (mp-show-waiting))
                        (b (show-buffer-chunks))
                        (v (print-visicon))
                        (r (buffer-status))
                        (d (pop (meta-p-events mp))))))))
       
       
       (multiple-value-bind (time events break)
           (run-sched-queue (current-mp) #'test :real-time nil)
         (unless break
           (send-run-terminated-events (current-mp))
           (meta-p-output (format-event (make-act-r-event 
                                         :mstime (meta-p-time (current-mp))
                                         :module "------"
                                         :model '-
                                         :details "Stepping stopped"
                                         :output t
                                         :mp (current-meta-process)))))
         (values (ms->seconds time) events break))))))

(defun schedule-event (time action 
                            &key (maintenance nil)
                            (module :none) (destination nil)
                            (priority 0) (params nil) 
                            (details nil) (output t)
                            (time-in-ms nil))
  (verify-current-mp  
   "schedule-event called with no current meta-process."
   (verify-current-model
    "schedule-event called with no current model."
    (let ((mp (current-mp)))
      (cond ((not (and (numberp time) (>= time 0)))
             (print-warning "Time must be non-negative number."))
            ((not (or (functionp action) (fboundp action)))
             (print-warning "Can't schedule ~S not a function or function name." action))
            ((and (symbolp action) (macro-function action))
             (print-warning "Can't schedule ~S because it is a macro and not a function." action))
            ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
             (print-warning "Priority must be a number or :min or :max."))
            ((not (listp params))
             (print-warning "params must be a list."))
            ((and time-in-ms (not (integerp time)))
             (print-warning "When time-in-ms is true the time must be an integer."))
            (t
             (let ((new-event (funcall (if maintenance
                                           #'make-act-r-maintenance-event
                                         #'make-act-r-event) 
                                       :mp (meta-p-name mp)
                                       :model (current-model)
                                       :module module
                                       :mstime (if time-in-ms time (seconds->ms time))
                                       :priority priority
                                       :action action
                                       :params params
                                       :details details
                                       :output output
                                       :destination destination)))
               
               (insert-queue-event mp new-event)
               
               (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                 (update-waiting-events mp new-event))
               
               new-event)))))))


(defun schedule-maintenance-event (time action &rest r)
  (declare (ignore time action r))
  (print-warning "The schedule-maintenance functions no longer exist.")
  (print-warning "Instead there is now a maintenance keyword accepted by the regular schedule-* functions."))


;;; insert-queue-event
;;;
;;; This function takes two parameter which are a meta-process and an
;;; event.  The event is added to the list of scheduled events for the
;;; meta-process in order based on its time and priority.
;;;
;;; Items are ordered by time first, lower times occuring before higher
;;; times.  If two events have the same time then:
;;;
;;; An event with priority :max occurs before any event in the queue with
;;;                             the same time except existing events of :max
;;;                             priority
;;; An event with a numeric priority occurs before an event with a lesser
;;;                             numbered priority or a priority of :min
;;; An event with priority :min occurs after any events at that time
;;;

(defun insert-queue-event (mp event)
  "Place an event into the scheduled-events list maintaing the ordering"
  (when (< (evt-mstime event) (meta-p-time mp))
    (print-warning "Event with action ~s and time ~s specifies a time that's already past.  Scheduling for current time ~s."
                   (evt-action event) (evt-time event) (mp-time ))
    (setf (evt-mstime event) (meta-p-time mp)))
  (if (null (meta-p-events mp))
      (push event (meta-p-events mp))
    (setf (meta-p-events mp)
      (do* ((pos 0 (1+ pos))
            (queue (meta-p-events mp) (cdr queue)))
           ((or (null queue)
                (eq :left (compare-events event (car queue))))
            (splice-into-list-des (meta-p-events mp) pos event))))))


(defun compare-events (new-event old-event)
  (if (or (> (evt-mstime new-event) (evt-mstime old-event))
          (and (= (evt-mstime new-event) (evt-mstime old-event))
               (or (eq (evt-priority new-event) :min)
                   (eq (evt-priority old-event) :max)
                   (and (numberp (evt-priority new-event))
                        (numberp (evt-priority old-event))
                        (<= (evt-priority new-event) 
                            (evt-priority old-event))))))
      
      :right :left))

;;; update-waiting-events
;;;
;;; This function takes two parameters, a meta-process and an event.  The 
;;; list of waiting events for the meta-process is checked to see if the
;;; event specified allows any of them to be added to the scheduled events.
;;; If an event can be moved to the scheduled events list it is removed
;;; from the waiting events list and it is added to the scheduled events
;;; list (which will call update-waiting-events to test whether that event
;;; frees others from the waiting list).
;;; The list of dynamic events is also tested in the same way as the
;;; waiting events.

(defun update-waiting-events (mp new-event)
  "Check the list of waiting events to see if a new event allows any to run"
  (let ((moved-events nil))
    (dolist (event (meta-p-delayed mp))
      (when (conditions-met event new-event)
        (setf (meta-p-delayed mp) (remove event (meta-p-delayed mp)))
        (unless (evt-dynamic event)
          (setf (evt-wait-condition event) nil))
        (push event moved-events)))
    
    (dolist (event-check (meta-p-dynamics mp))
      (let ((event (car event-check))
            (cur-time (cdr event-check)))
        (when (and (< (evt-mstime new-event) cur-time)
                   (conditions-met event new-event))
          (delete-event event)
          (push event moved-events))))
    
    (dolist (event moved-events)
      (let ((n-event
             (if (act-r-break-event-p event)
                 (schedule-break (evt-mstime new-event)
                                 :priority :min
                                 :details (evt-details event)
                                 :time-in-ms t)
               (schedule-event (evt-mstime new-event)
                               (evt-action event)
                               :time-in-ms t
                               :module (evt-module event)
                               :details (evt-details event)
                               :params (evt-params event)
                               :priority :min
                               :output (evt-output event) 
                               :destination (evt-destination event)
                               :maintenance (act-r-maintenance-event-p event)))))
        (when (evt-dynamic event)
          (setf (evt-dynamic n-event) t)
          (setf (evt-wait-condition n-event) (evt-wait-condition event))
          (push (cons n-event (evt-mstime new-event)) (meta-p-dynamics mp)))))))

;;; conditions-met
;;;
;;; This function takes two parameters which are a waiting-event and a
;;; new-event.  

(defun conditions-met (w-event new-event)
  "Test whether a waiting event's wait-for reason is met by a new event"
  (case (car (evt-wait-condition w-event))
    (:any (and (eq (evt-model w-event) (evt-model new-event))
               (or (second (evt-wait-condition w-event))
                   (not (act-r-maintenance-event-p new-event)))))
    
    (:module (and (or (eq (evt-model w-event) (evt-model new-event))
                      (null (evt-model w-event)))
                  (eq (second (evt-wait-condition w-event)) 
                      (evt-module new-event))
                  (or (third (evt-wait-condition w-event))
                   (not (act-r-maintenance-event-p new-event)))))
    (t nil)))
  
  

(defun schedule-event-relative (time-delay action 
                                           &key (maintenance nil)
                                           (module :none) (destination nil)
                                           (priority 0) (params nil) 
                                           (details nil) (output t)
                                           (time-in-ms nil))
  (verify-current-mp  
   "schedule-event-relative called with no current meta-process."
   (verify-current-model
    "schedule-event-relative called with no current model."
    (let ((mp (current-mp)))
      (cond ((not (and (numberp time-delay) (>= time-delay 0)))
             (print-warning "Time-delay must be non-negative number."))
            ((not (or (functionp action) (fboundp action)))
             (print-warning 
              "Can't schedule ~S not a function or function name." action))
            ((and (symbolp action) (macro-function action))
             (print-warning "Can't schedule ~S because it is a macro and not a function." action))
            ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
             (print-warning "Priority must be a number or :min or :max."))
            ((not (listp params))
             (print-warning "params must be a list."))
            ((and time-in-ms (not (integerp time-delay)))
             (print-warning "When time-in-ms is true the time-delay must be an integer."))
            (t
             (let ((new-event 
                    (funcall (if maintenance
                                 #'make-act-r-maintenance-event
                               #'make-act-r-event)
                             :mp (meta-p-name mp)
                             :model (current-model) 
                             :module module
                             :mstime (+ (meta-p-time mp) 
                                        (if time-in-ms time-delay (seconds->ms time-delay)))
                             :priority priority
                             :action action
                             :params params
                             :details details
                             :output output
                             :destination destination)))
               
               (insert-queue-event mp new-event)
               
               (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                 (update-waiting-events mp new-event))
               
               new-event)))))))


(defun schedule-maintenance-event-relative (time-delay action &rest r)
  (declare (ignore time-delay action r))
  (print-warning "The schedule-maintenance functions no longer exist.")
  (print-warning "Instead there is now a maintenance keyword accepted by the regular schedule-* functions."))





(defun schedule-event-after-module (after-module action 
                                                 &key (maintenance nil)
                                                 (module :none) (destination nil)
                                                 (params nil) (details nil) 
                                                 (output t) (delay t)
                                                 (include-maintenance nil)
                                                 (dynamic nil))
  (let ((first-val
         (verify-current-mp  
          "schedule-event-after-module called with no current meta-process."
          (verify-current-model
           "schedule-event-after-module called with no current model."
           (let ((mp (current-mp)))
             (cond ((not (valid-module-name after-module))
                    (print-warning "after-module must name a module."))
                   ((not (or (functionp action) (fboundp action)))
                    (print-warning "Can't schedule ~S not a function or function name." action))
                   ((and (symbolp action) (macro-function action))
                    (print-warning "Can't schedule ~S because it is a macro and not a function." action))
                   ((not (listp params))
                    (print-warning "params must be a list."))
                   (t
                    (let* ((new-event 
                            (funcall (if maintenance
                                         #'make-act-r-maintenance-event
                                       #'make-act-r-event)
                                     :mp (meta-p-name mp)
                                     :model (current-model) 
                                     :module module
                                     :priority :min
                                     :action action
                                     :params params
                                     :details details
                                     :output output
                                     :destination destination
                                     :dynamic (and dynamic (meta-p-allow-dynamics mp))
                                     :wait-condition 
                                     (list :module after-module 
                                           include-maintenance)))
                           (matching-event 
                            (find-if #'(lambda (x)
                                         (conditions-met new-event x))
                                     (meta-p-events mp))))
                      (cond (matching-event 
                             (setf (evt-mstime new-event) 
                               (evt-mstime matching-event))
                             
                             
                             (unless (evt-dynamic new-event)
                               (setf (evt-wait-condition new-event) nil))
                             
                             (when (evt-dynamic new-event)
                               (push (cons new-event (evt-mstime new-event)) (meta-p-dynamics mp)))
                             
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                                                          
                             new-event)
                            ((null delay)
                             (setf (evt-mstime new-event) (meta-p-time mp))
                             (setf (evt-priority new-event) :max)
                             (setf (evt-wait-condition new-event) nil)
                             (setf (evt-dynamic new-event) nil)
                             
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                             
                             new-event)
                            ((eq delay :abort)
                             :abort)
                            (t
                             (push new-event (meta-p-delayed mp))
                             new-event))))))))))
    (if first-val
        (if (act-r-event-p first-val)
            (values first-val (if (evt-wait-condition first-val) t nil))
          (values nil :abort))
      (values nil nil))))
                             

(defun schedule-event-after-change (action 
                                    &key (maintenance nil)
                                    (module :none) (destination nil)
                                    (params nil) (details nil) 
                                    (output t) (delay t)
                                    (include-maintenance nil)
                                    (dynamic nil))

  (let ((first-val
         (verify-current-mp  
          "schedule-event-after-change called with no current meta-process."
          (verify-current-model
           "schedule-event-after-change called with no current model."
           (let ((mp (current-mp)))
             (cond ((not (or (functionp action) (fboundp action)))
                    (print-warning "Can't schedule ~S not a function or function name." action))
                   ((and (symbolp action) (macro-function action))
                    (print-warning "Can't schedule ~S because it is a macro and not a function." action))
                   ((not (listp params))
                    (print-warning "params must be a list."))
                   (t
                    (let* ((new-event 
                            (funcall (if maintenance
                                         #'make-act-r-maintenance-event
                                       #'make-act-r-event)
                                     :mp (meta-p-name mp)
                                     :model (current-model) 
                                     :module module
                                     :priority :min
                                     :action action
                                     :params params
                                     :details details
                                     :output output
                                     :destination destination
                                     :dynamic (and dynamic (meta-p-allow-dynamics mp))
                                     :wait-condition (list :any include-maintenance)))
                           (matching-event 
                            (find-if #'(lambda (x)
                                         (conditions-met new-event x))
                                     (meta-p-events mp))))
                      (cond (matching-event 
                             (setf (evt-mstime new-event) 
                               (evt-mstime matching-event))
                             
                             (unless (evt-dynamic new-event)
                               (setf (evt-wait-condition new-event) nil))
                             
                             (when (evt-dynamic new-event)
                               (push (cons new-event (evt-mstime new-event)) (meta-p-dynamics mp)))
                                    
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                             
                             new-event)
                            ((null delay)
                             (setf (evt-mstime new-event) (meta-p-time mp))
                             (setf (evt-priority new-event) :max)
                             (setf (evt-wait-condition new-event) nil)
                             (setf (evt-dynamic new-event) nil)
                             
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                                                          
                             new-event)
                            ((eq delay :abort)
                             :abort)
                            (t
                             (push new-event (meta-p-delayed mp))
                             new-event))))))))))
    (if first-val
        (if (act-r-event-p first-val)
            (values first-val (if (evt-wait-condition first-val) t nil))
          (values nil :abort))
      (values nil nil))))




(defun schedule-periodic-event (period action 
                                       &key (maintenance nil)
                                       (module :none) (destination nil)
                                       (priority 0) (params nil) 
                                       (details nil) (output t)
                                       (initial-delay 0)
                                       (time-in-ms nil))
  
  (verify-current-mp  
   "schedule-periodic-event called with no current meta-process."
   (verify-current-model
    "schedule-event called with no current model."
    (let ((mp (current-mp)))
      (cond ((not (and (numberp period) (> period 0)))
             (print-warning "period must be greater than 0."))
            ((not (and (numberp initial-delay) (>= initial-delay 0)))
             (print-warning "initial-dealy must be a non-negative number."))
            ((not (or (functionp action) (fboundp action)))
             (print-warning "Can't schedule ~S not a function or function name." action))
            ((and (symbolp action) (macro-function action))
             (print-warning "Can't schedule ~S because it is a macro and not a function." action))
            ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
             (print-warning "Priority must be a number or :min or :max."))
            ((not (listp params))
             (print-warning "params must be a list."))
            ((and time-in-ms (or (not (integerp period)) (not (integerp initial-delay))))
             (print-warning "When time-in-ms is true the period and initial-delay must be integers."))
            (t
             (let* ((real-event (funcall (if maintenance
                                             #'make-act-r-maintenance-event
                                           #'make-act-r-event) 
                                         :mp (meta-p-name mp)
                                         :model (current-model) 
                                         :module module
                                         :priority :max
                                         :action action
                                         :params params
                                         :details details
                                         :output output
                                         :destination destination))
                    (id (incf *periodic-event-id-counter*))
                    (periodic-event 
                     (make-act-r-periodic-event 
                      :id id
                      :mp (meta-p-name mp)
                      :module :none
                      :model (current-model) 
                      :mstime (+ (meta-p-time mp) (if time-in-ms initial-delay (seconds->ms initial-delay)))
                      :priority priority
                      :action 'periodic-action
                      :params 
                      (list id real-event (if time-in-ms period (seconds->ms period))
                            priority)
                      :output nil
                      :details 
                      ;(format nil 
                      ;    "Periodic Action: ~A Period: ~A" action period)
                      (concatenate 'string
                        "Periodic-Action "
                        (if (and (symbolp action) (fboundp action)) (symbol-name action) "Unnamed function")
                        " "
                        (princ-to-string period))
                      )))
               
               (insert-queue-event mp periodic-event)
               
               (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                 (update-waiting-events mp periodic-event))
               
               periodic-event)))))))


(defun periodic-action (id event period priority)
  (let* ((mp (current-mp))
         (periodic-event 
          (make-act-r-periodic-event 
           :id id
           :mp (evt-mp event)
           :model (evt-model event) 
           :module :none
           :mstime (+ (meta-p-time mp) period)
           :priority priority
           :action 'periodic-action
           :params (list id event period priority)
           :output nil
           :details 
           ;(format nil 
           ;    "Periodic Action: ~A Period: ~A" (evt-action event) period)
           (concatenate 'string
                        "Periodic-Action "
                        (princ-to-string (evt-action event))
                        " "
                        (princ-to-string period)))))
    
    (setf (evt-mstime event) (meta-p-time mp))
    
    (insert-queue-event mp event)
    
    (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
      (update-waiting-events mp event))
    
    (insert-queue-event mp periodic-event)
    
    (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
      (update-waiting-events mp periodic-event))))
    
  
(defun schedule-break (time &key (priority :max) (details nil)(time-in-ms nil))
  (verify-current-mp  
   "schedule-break called with no current meta-process."
   (let ((mp (current-mp)))
     (cond ((not (and (numberp time) (>= time 0)))
            (print-warning "Time must be non-negative number."))
           ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
            (print-warning "Priority must be a number or :min or :max."))
           ((and time-in-ms (not (integerp time)))
            (print-warning "When time-in-ms is true the time must be an integer."))
           (t
            (let ((new-event (make-act-r-break-event :mp (meta-p-name mp)
                                                     :mstime (if time-in-ms time (seconds->ms time))
                                                     :params (list mp)
                                                     :priority priority
                                                     :details details)))
               
               (insert-queue-event mp new-event)
              
              (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                (update-waiting-events mp new-event))
              
              new-event))))))


(defun schedule-break-relative (time-delay 
                                &key (priority :max) (details nil)(time-in-ms nil))
  (verify-current-mp  
   "schedule-break-relative called with no current meta-process."
   (let ((mp (current-mp)))
     (cond ((not (and (numberp time-delay) (>= time-delay 0)))
            (print-warning "Time-delay must be non-negative number."))
           ((not (or (numberp priority) (eq priority :min) (eq priority :max)))
            (print-warning "Priority must be a number or :min or :max."))
           ((and time-in-ms (not (integerp time-delay)))
            (print-warning "When time-in-ms is true the time-delay must be an integer."))
           (t
            (let ((new-event (make-act-r-break-event 
                              :mp (meta-p-name mp)
                              :mstime (+ (meta-p-time mp) (if time-in-ms time-delay (seconds->ms time-delay)))
                              :params (list mp)
                              :priority priority
                              :details details)))
               
               (insert-queue-event mp new-event)
              
              (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                (update-waiting-events mp new-event))
              
              new-event))))))

(defun schedule-break-after-module (after-module 
                                    &key (details nil) (delay t)(dynamic nil))
  
  (let ((first-val
         (verify-current-mp  
          "schedule-break-after-module called with no current meta-process."
          (verify-current-model
           "schedule-break-after-module called with no current model."
           (let ((mp (current-mp)))
             (cond ((not (valid-module-name after-module))
                    (print-warning "after-module must name a module."))
                   (t
                    (let* ((new-event (make-act-r-break-event 
                                       :mp (meta-p-name mp)
                                       :model (current-model)
                                       :priority :min
                                       :params (list mp)
                                       :details details
                                       :dynamic (and dynamic (meta-p-allow-dynamics mp))
                                       :wait-condition 
                                       (list :module after-module t)))
                           (matching-event 
                            (find-if #'(lambda (x)
                                         (conditions-met new-event x))
                                     (meta-p-events mp))))
                      (cond (matching-event 
                             (setf (evt-mstime new-event) 
                               (evt-mstime matching-event))
                             
                             (unless (evt-dynamic new-event)
                               (setf (evt-wait-condition new-event) nil))
                             
                             (when (evt-dynamic new-event)
                               (push (cons new-event (evt-mstime new-event)) (meta-p-dynamics mp)))
                                                          
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                             new-event)
                            ((null delay)
                             (setf (evt-mstime new-event) (meta-p-time mp))
                             (setf (evt-priority new-event) :max)
                             (setf (evt-wait-condition new-event) nil)
                             (setf (evt-dynamic new-event) nil)
                             
                             (insert-queue-event mp new-event)
                             
                             (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
                               (update-waiting-events mp new-event))
                             new-event)
                            ((eq delay :abort)
                             :abort)
                            (t
                             (push new-event (meta-p-delayed mp))
                             new-event))))))))))
        (if first-val
            (if (act-r-event-p first-val)
                (values first-val (if (evt-wait-condition first-val) t nil))
              (values nil :abort))
          (values nil nil))))
  


(defun schedule-break-after-all (&key (details nil))
  (verify-current-mp  
   "schedule-break called with no current meta-process."
   (let* ((mp (current-mp))
          (new-event (make-act-r-break-event :mp (meta-p-name mp)
                                             :params (list mp)
                                             :priority :min
                                             :details details)))
     
     
     (setf (evt-mstime new-event) (if (meta-p-events mp)
                                    (evt-mstime (car (last (meta-p-events mp))))
                                  (meta-p-time mp)))
     
     (insert-queue-event mp new-event)
          
     (when (or (meta-p-delayed mp) (meta-p-dynamics mp))
       (update-waiting-events mp new-event))
     
     new-event)))

(defmethod delete-event ((event t))
  (print-warning "~S is not a valid event." event))


(defmethod delete-event ((event act-r-event))
  (verify-current-mp  
   "delete-event called with no current meta-process."
   (let ((mp (current-mp)))
     
     (cond ((find event (meta-p-events mp))
            (setf (meta-p-events mp) (remove event (meta-p-events mp)))
            (when (evt-dynamic event)
              (setf (meta-p-dynamics mp) (remove event (meta-p-dynamics mp) :key #'car)))
            t)
           ((find event (meta-p-delayed mp))
            (setf (meta-p-delayed mp) (remove event (meta-p-delayed mp)))
            t)
           (t
            nil)))))


;; A periodic event can't be dynamic so don't worry about adding that
;; here...

(defmethod delete-event ((event act-r-periodic-event))
  (verify-current-mp  
   "delete-event called with no current meta-process."
   (let* ((mp (current-mp))
          (events (find (act-r-periodic-event-id event) 
                        (meta-p-events mp) 
                        :key #'(lambda (x) 
                                 (and (eq (type-of x) 'act-r-periodic-event)
                                      (act-r-periodic-event-id x)))))
          (waiting (find (act-r-periodic-event-id event) 
                         (meta-p-delayed mp) 
                         :key #'(lambda (x) 
                                  (and (eq (type-of x) 'act-r-periodic-event)
                                       (act-r-periodic-event-id x))))))
     
     (cond (events
            (setf (meta-p-events mp) 
              (remove (act-r-periodic-event-id event) 
                      (meta-p-events mp) 
                      :key #'(lambda (x) 
                               (and (eq (type-of x) 'act-r-periodic-event)
                                    (act-r-periodic-event-id x)))))
            t)
           (waiting 
            (setf (meta-p-delayed mp) 
              (remove (act-r-periodic-event-id event) 
                      (meta-p-delayed mp) 
                      :key #'(lambda (x) 
                               (and (eq (type-of x) 'act-r-periodic-event)
                                    (act-r-periodic-event-id x)))))
            t)
           (t
            nil)))))
    

(defun add-pre-event-hook (hook-fn &optional (warn t))
  (verify-current-mp
   "add-pre-event-hook called with no current meta-process"
   (let ((mp (current-mp)))
     (cond ((not (or (functionp hook-fn) (fboundp hook-fn)))
            (print-warning 
             "parameter ~s to add-pre-event-hook is not a function" hook-fn))
           ((member hook-fn (meta-p-pre-events mp))
            (when warn
              (print-warning 
               "~s is already on the pre-event-hook list not added again"
               hook-fn)))
           (t (push hook-fn (meta-p-pre-events mp))
              (setf (gethash (meta-p-next-hook-id mp) (meta-p-hook-table mp))
                (cons :pre hook-fn))
              (1- (incf (meta-p-next-hook-id mp))))))))
         
         

(defun add-post-event-hook (hook-fn &optional (warn t))
  (verify-current-mp
   "add-post-event-hook called with no current meta-process"
   (let ((mp (current-mp)))
     (cond ((not (or (functionp hook-fn) (fboundp hook-fn)))
            (print-warning 
             "parameter ~s to add-post-event-hook is not a function" hook-fn))
           ((member hook-fn (meta-p-post-events mp))
            (when warn
              (print-warning 
               "~s is already on the post-event-hook list not added again" 
               hook-fn)))
           (t (push hook-fn (meta-p-post-events mp))
              (setf (gethash (meta-p-next-hook-id mp) (meta-p-hook-table mp))
                (cons :post hook-fn))
              (1- (incf (meta-p-next-hook-id mp))))))))


(defun delete-event-hook (hook-fn-id)
  (verify-current-mp
   "delete-event-hook called with no current meta-process"
   (let* ((mp (current-mp))
          (event (gethash hook-fn-id (meta-p-hook-table mp))))
     (when event
       (remhash hook-fn-id (meta-p-hook-table mp))
       (if (eq :pre (car event))
           (setf (meta-p-pre-events mp) 
             (remove (cdr event) (meta-p-pre-events mp)))
         (setf (meta-p-post-events mp) 
             (remove (cdr event) (meta-p-post-events mp))))
       (cdr event)))))


#|
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
|#
