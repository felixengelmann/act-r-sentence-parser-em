;;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Author      : Dan Bothell
;;; Copyright   : (c) 2004-2007 Dan Bothell
;;; Availability: Covered by the GNU LGPL, see LGPL.txt
;;; Address     : Department of Psychology 
;;;             : Carnegie Mellon University
;;;             : Pittsburgh, PA 15213-3890
;;;             : db30@andrew.cmu.edu
;;; 
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Filename    : production-compilation.lisp
;;; Version     : 1.5
;;; 
;;; Description : First pass at production compilation in ACT-R 6.
;;; 
;;; Bugs        : 
;;;
;;; To do       : [ ] Consider the handling of !safe-bind! in respect to doing
;;;             :     a direct substitution with the instantiated binding.
;;;             : [ ] With the addition of the compilation-instan parameter
;;;             :     it may be possible to put the goal style slot remapping
;;;             :     back into the goal mapping function instead of directly
;;;             :     in the composition function, and then remove the clean-up
;;;             :     hack at the end.  Not entirely sure, but definitely worth
;;;             :     investigating at some point.
;;; ----- History -----
;;; 2005.04.26 Dan
;;;             : * Initial creation.
;;;
;;; 2005.05.18 Dan
;;;             : * Works to compose now, but doesn't yet have the parameter
;;;             :   learning pieces.
;;; 2005.05.19 Dan
;;;             : * Note that productions generated by compilation are 
;;;             :   created with p* because p*'s are a super set of p's
;;;             :   and that way p*'s can go through compilation without 
;;;             :   any special handling!
;;;             : * Fixed a bug in the composing functions because if a
;;;             :   buffer isn't mentioned in the first production it doesn't
;;;             :   actually have an index of 0.
;;;             : * Added the utility equation pieces, so it should be "fully"
;;;             :   operational (noting that it isn't defined if parameter
;;;             :   learning is set to use a decay value).
;;; 2005.05.20 Dan
;;;             : * Adding the threshold-time parameter.
;;; 2005.05.24 Dan
;;;             : * Some general clean up for speed and ease of reading for
;;;             :   the newly formed productions.
;;; 2005.05.25 Dan
;;;             : * Fixed an issue in compose-productions where ACL was letting
;;;             :   me get away with some sloppy code.
;;; 2005.05.26 Dan
;;;             : * Some more minor clean up for ease of reading the
;;;             :   the new productions - take out all = slot modifiers and
;;;             :   order the conditions as buffer tests, buffer queries, and
;;;             :   then !'s with the tests and queries in alphabetical order
;;;             :   by buffer name.
;;; 2005.05.27 Dan
;;;             : * Make sure that the compilation is disabled on a reset.
;;;             : * Added the initial-successes, initial-failures, and initial-
;;;             :   efforts parameters.
;;; 2005.06.01 Dan
;;;             : * Fixed a bug in compilation under MCL buffer-condition-
;;;             :   union was trying to set the second of something that was
;;;             :   nil which isn't a good idea, but didn't break in ACL though
;;;             :   I don't know why.
;;;             : * Ammended the tests for a valid production to include not 
;;;             :   having any direct requests and not using any slot modifiers
;;;             :   other than = for now.
;;; 2005.06.02 Dan
;;;             : * Some minor updates. 
;;;             : * Need to check that production name isn't already used 
;;;             :   explicitly since new-name only checks chunk names.
;;;             : * The test for slot modifiers needs to not look at evals and
;;;             :   binds because they may have similar structure...
;;; 2005.06.06 Dan
;;;             : * Fixed a bug in buffer-condition-union because it could be
;;;             :   the case that the first condition is blank and thus one
;;;             :   can't delete the isa from the second in that case.
;;; 2005.06.08 Dan
;;;             : * Changed define-chunk-spec-fct to define-variable-chunk-
;;;             :   spec-fct in produce-standard-representation because 
;;;             :   otherwise it blocks p*'s from being composed.  Since the
;;;             :   chunk-spec wasn't being use other than to order the
;;;             :   production components it shouldn't create any problems...
;;; 2005.06.16 Dan
;;;             ; * Fixed a bug in compose-productions with respect to
;;;             :   !safe-bind! because it wasn't properly copying all the
;;;             :   necessary pieces into the newly composed production.
;;;             : * Changed compose-productions so that it correctly orders
;;;             :   RHS safe-binds because the p2 bindings may depend on the
;;;             :   bindings of p1.  It also now checks to make sure that a
;;;             :   new production gets created without error to revent it 
;;;             :   from just crashing if that happens for some reason.
;;; 2005.08.15 Dan
;;;             : * Fixed a bug in that the hooks weren't removed if epl was
;;;             :   toggled from t to nil.  Thus, prior to this fix the only
;;;             :   way to disable was a reset once it was enabled.
;;; 2005.08.16 Dan
;;;             : * Fixed problems with the handling of !safe-bind! on the RHS.
;;;             :   The issues were if the substitution resulted in the var
;;;             :   being bound mapping onto a constant or if the var being
;;;             :   bound ends up on the LHS of the composed production after
;;;             :   mapping.  The solution (for now) is to convert those to
;;;             :   LHS !safe-eval! tests on the value in question instead.
;;;             : - Another potential solution is to treat !safe-bind! actions
;;;             :   like retrievals and just do the constant substitution with
;;;             :   the instantiated value.
;;;             : * Another situation with binds popped up - a RHS bind + a
;;;             :   LHS eval can result in an odd combination with an unbound
;;;             :   variable, so to fix that there's currently a fix to move
;;;             :   the bind to the LHS.  That then makes the new production
;;;             :   a dead end for compilation, but doesn't cause the system
;;;             :   to crash.
;;; 2005.08.17 Dan
;;;             : * Major change in how !safe-bind! is handled!
;;;             :   Now, instead of trying to catch all the gotchas, a RHS
;;;             :   binding in the first production will be treated like a
;;;             :   retrieval for substitution - the explicit value bound
;;;             :   in the instantiation will be propigated forward into the
;;;             :   new production and the form that was evaluated will be
;;;             :   discarded.
;;;             :   That means that there should be no side effects in the
;;;             :   evaluation of a !safe-bind! because they will not be
;;;             :   carried over to a compiled production!
;;; 2005.08.19 Dan
;;;             : * Continuing to update how binds work.  Not only will the
;;;             :   value of the bound variable be captured, but all variables
;;;             :   that are referenced in the bind expression will be replaced
;;;             :   with their instantiated values from the first production.
;;; 2005.08.22 Dan
;;;             : * More work on the mechanism.  Now, adding a (somewhat)
;;;             :   redundant check to make sure productions are compatible.
;;;             :   This check ensures that a buffer doesn't violate the
;;;             :   assumptions that underlie the style - for instance that
;;;             :   the goal chunk doesn't change other than through a
;;;             :   production.
;;;             :   Right now it's only a check of goal style buffers because
;;;             :   we want partial matching (which may be inconsistent) for
;;;             :   retrieval style buffers and motor and perceptual buffers
;;;             :   don't compile across modifications or requests to begin
;;;             :   with.  This needs to be made more general though so that
;;;             :   it also can be user extended.
;;; 2005.09.01 Dan
;;;             : * Added a call to with-unchecked-p* around the generation of
;;;             :   the new production to allow non-variable new slot creation
;;;             :   (which could happen after substitution in a generated
;;;             :   production).
;;; 2005.09.02 Dan
;;;             : * Patch work to fix issues with p* in general that were
;;;             :   uncovered while testing the slot creation code.
;;;             :   Main issue is that modifications in the first production
;;;             :   need to have the slot names instantiated so that all the
;;;             :   conditions of the second that were set by the first can
;;;             :   be detected.
;;;             : * Since only goal style modules allow buffer modification,
;;;             :   that's where I've applied the fix, but if other styles are
;;;             :   to allow mods then that will have to be handled there too.
;;; 2005.11.09 Dan
;;;             : * Fix for a problem in composing a p1 that makes a retrieval
;;;             :   request with a p2 that doesn't mention retrieval at all.
;;;             :   The request was being dropped, but shouldn't have been.
;;; 2005.12.12 Dan
;;;             : * Temporary fix to composing p* variablized slots (instead of
;;;             :   just instantiating them).  This is a hack John put in and
;;;             :   I'm working on making it more general.
;;; 2005.12.14 Dan
;;;             : * Moved the fix into the goal-style buffers explicitly since
;;;             :   they're the only ones where it's an issue because none of
;;;             :   the other styles allow for a RHS modification.
;;; 2005.12.15 Dan
;;;             : * Realized that I can't do it in the goal buffer processing
;;;             :   because the "normal" variable mapping process needs the
;;;             :   change before it progresses (which occurs before it goes
;;;             :   to the buffer specific code).  So, it's in the main 
;;;             :   function and conditionalized to only occur for the special
;;;             :   case necessary (goal style buffer with a RHS modification).
;;; 2005.12.20 Dan
;;;             : * Minor changes to clean up some compiler warnings.
;;; 2006.01.17 Dan
;;;             : * Time to change the version number and module info text.
;;;             :   It's now version 1.0.
;;; 2006.02.03 Dan
;;;             : * Another issue with p*'s that I don't really have a good
;;;             :   handle on at this point (see pstar-test8.lisp in the test-
;;;             :   models folder for an example).  So, for now I've taken the
;;;             :   easiest approach and just clean-up after the fact.  Which
;;;             :   might be a good idea in general, but doesn't feel quite
;;;             :   right...
;;; 2006.02.07 Dan
;;;             : * Make sure that the RHS !safe-bind! calls in p2 come before the
;;;             :   !safe-eval! and !output! calls in p3 to avoid issues with
;;;             :   unbound vars.  Maintaining original order might be a nice
;;;             :   thing to have, but the "standard rep" loses that at this 
;;;             :   point to allow for better comparisons.  So, if that's really
;;;             :   necessary it'll require some more extensive changes.
;;; 2006.03.10 Dan
;;;             : * Fixed calls to get-production because it no longer requires
;;;             :   the procedural module as a parameter.
;;;             : * Removed the learned-productions slot of the module and
;;;             :   instead made it a parameter on the productions themselves.
;;;             : * Updated update-params-for-compiled-production to not do
;;;             :   the utility computation, but instead to call the functions
;;;             :   in the utility-and-reward file.
;;; 2006.03.13 Dan
;;;             : * Removed all the utility parameters from the compilation
;;;             :   module because they're now part of the utility module.
;;; 2006.03.14 Dan
;;;             : * Fixed a bug that was introduced with the !safe-bind! fix
;;;             :   that caused RHS buffer references to be instantiated.
;;; 2006.03.14 Dan
;;;             : * Switched call to pp to (all-productions).
;;; 2006.07.12 Dan
;;;             : * Fixed the typo in the documentation of the :pct parameter.
;;; 2006.08.29 Dan
;;;             : * Fixed a bug in compose-productions where it was creating
;;;             :   the comment string for the new production.  It was iterating
;;;             :   over all buffers to determine if any were "removed" which
;;;             :   would throw a warning for a buffer that wasn't used now.
;;;             :   Instead, it only needs to check the buffers actually used
;;;             :   on the LHS of p2 which avoids the bug and is generally 
;;;             :   going to save a little time during compilation.
;;; 2006.09.07 Dan
;;;             : * Changed reset-production-compilation so that imaginal is
;;;             :   a goal type by default.
;;; 2006.11.10 Dan
;;;             : * Use the new dynamic slot of productions so that compilation
;;;             :   only creates p*s when a parent production is a p*.
;;; 2006.11.16 Dan
;;;             : * Changed update-params-for-compiled-production so that when
;;;             :   it deletes the new productions it also releases the name
;;;             :   symbol using release-name.
;;; 2006.11.17 Dan
;;;             : * Added a compilation-buffer-type macro and renamed the
;;;             :   function with -fct.
;;;             : * Added a call to values around the gethash in compilation-
;;;             :   buffer-type to suppress the second return value.
;;;             : * Changed specify-compilation-buffer-type to return t/nil only.
;;;             : * Fixed a bug in specify-compilation-buffer-type because it
;;;             :   was missing parameters in the calls to print-warning.
;;; 2007.01.15 Dan
;;;             : * Fixed a bug that was introduced with the change on 11/16
;;;             :   that would break when releasing the name.
;;; 2007.02.01 Dan
;;;             : * Fixed a bug in the instantiating necessary when a goal
;;;             :   style buffer in a p* modifies a chunk with a variablized
;;;             :   slot, or after any modification the p2 has a variablized
;;;             :   condition test.  Previously it only instantiated if both
;;;             :   cases where satisfied instead of either which could lead
;;;             :   to "incorrect" productions.  Probably a pretty rare situation,
;;;             :   since p*'s and production compilation are both sparsely 
;;;             :   used so I'm guessing that this hasn't been an issue for 
;;;             :   anyone else. (John didn't even encounter it!)
;;; 2007.04.10 Dan
;;;             : * Changed the comment string added to the new production so
;;;             :   that it only indicates the '- chunk' when the first production
;;;             :   actually made a request to the retrieval type buffer which
;;;             :   was matched in the second.  Previously, as long as the
;;;             :   second production tested such a buffer it would add that
;;;             :   to the comment.
;;;             : * Fixed a bad bug in compose-retrieval-buffer.  If p1 had
;;;             :   a retrieval request and p2 had a query of that buffer without
;;;             :   a harvest (thus it must be state busy or buffer empty) then
;;;             :   the composed production actually dropped the request from
;;;             :   the actions as if it was harvested!
;;;             : * Added a fix for an issue with retrieval drop-out when
;;;             :   the request had dynamic slot names.  There are still
;;;             :   a couple of issues to work out, but this should catch
;;;             :   many of the current problem cases.
;;; 2007.04.11 Dan
;;;             : * Added a better check for whether a compiled production is
;;;             :   dynamic and should be created with p* instead of just assuming
;;;             :   that it was based on the parents.
;;;             : * Added a new parameter to productions: compilation-instan.
;;;             :   It's used to hold the instantiation of p2 during compilation 
;;;             :   which is the bindings from the matching of p2 where some of the
;;;             :   variables may have been renamed to avoid conflicts with the 
;;;             :   variables from p1.
;;;             : * Using that new parameter, fixed a bug in the drop-out of
;;;             :   a retrieval which involved dynamic slots that had been renamed
;;;             :   in p2.
;;; 2007.05.21 Dan
;;;             : * Fix a bug that surprised me because nobody had found it yet -
;;;             :   when compiling out a retrieval if p2 used the "dropped" buffer
;;;             :   variable on the RHS it wasn't instantiated.  Not as easy a 
;;;             :   fix as first thought either because p1 could use that variable
;;;             :   name on it's LHS or RHS and those shouldn't be replaced...
;;;             : * Required adding the new production parameter retrieval-buffers-map
;;;             :   to keep things straight (sort of a hack, but I think it works
;;;             :   out ok).
;;; 2007.05.22 Dan
;;;             : * Similar to the bug listed above, compilation over goal style buffers
;;;             :   is allowed to progress (or fails with a warning in some cases)
;;;             :   when there is a use of the buffer variable in the actions of
;;;             :   p2 but a request in p1 invalidates that for the compiled production.
;;;             :   Updated the spreadsheet/data table to add a check for that.
;;; 2007.07.03 Dan
;;;             : * Fixed check-consistency because it was overly specific in
;;;             :   testing that things matched.  Replaced the eq test of the
;;;             :   slot contents with chunk-slot-equal.
;;; 2007.10.26 Dan [1.3]
;;;             : * Sorting the actions in the composed productions so that
;;;             :   the "same" production gets created in all systems.  Otherwise
;;;             :   they can vary in the action order which shouldn't matter, but
;;;             :   for some rare situations might.
;;; 2008.03.20 Dan
;;;             : * Putting in a test so that productions with multiple-value binds 
;;;             :   are always rejected from compilation.
;;; 2008.12.23 Dan
;;;             : * Put in code to make sure that new productions get added to
;;;             :   the procedural module the "right" way now.
;;; 2009.08.27 Dan
;;;             : * Added code to disable the consistency check between the
;;;             :   RHS modifications of p1 and the LHS tests of p2 for goal
;;;             :   style buffers when ppm is enabled.
;;; 2009.09.14 Dan
;;;             : * Fixed a bug in the consistency check added for the ppm change.
;;; 2010.11.22 Dan [1.4]
;;;             : * Start of the changes to update this to allow for buffer
;;;             :   modification requests, create a new type for imaginal,
;;;             :   and make things more easily extendable.
;;;             : * First pass is just the ability for get-buffer-index to
;;;             :   distinguish a normal request from a modification request
;;;             :   with modification requests just adding another bit to the
;;;             :   numbers.
;;;             : * Updated the docs to describe things a little better with
;;;             :   respect to the spreadsheets which are involved and are
;;;             :   how they are going to be used in the new implementation.
;;; 2010.11.23 Dan
;;;             : * Updated valid-1st-p to allow for both a modification and
;;;             :   standard request in a single production.
;;; 2010.11.24 Dan
;;;             : * Replaced the separate tables with a single table that
;;;             :   holds structures with a type's info.
;;; 2010.11.29 Dan
;;;             : * Don't like mixing changes, but in addition to updates for
;;;             :   the new more flexible compilation type handling I've added
;;;             :   some pre-caching of things that can take a while to compute
;;;             :   and are likely to be computed often: valid-1st-p, valid-for-
;;;             :   compilation, and a table for testing whether two productions
;;;             :   are composeable.
;;; 2010.12.06 Dan
;;;             : * Finished off the generalizing and moved all the buffer type
;;;             :   specific code to the corresponding files in the tools 
;;;             :   directory.  
;;;             : * Still need to clean up the details for the specifics of
;;;             :   handling the modification requests in those specific files.
;;; 2010.12.07 Dan
;;;             : * Changed update-params-... so that when :pct is on the
;;;             :   production is printed through print-production directly
;;;             :   instead of pp so that I can send it to the model trace 
;;;             :   instead of the command trace.
;;; 2010.12.15 Dan
;;;             : * Added the module as the first parameter passed to the 
;;;             :   mapping function.
;;; 2010.12.17 Dan
;;;             : * Added a new test to valid-compilation-production to check
;;;             :   for redundant variable usage.  It won't stop compilation,
;;;             :   but will print a warning if such useage is found.
;;; 2010.12.20 Dan
;;;             : * Allow the consistency check to pass for chunks of a subtype
;;;             :   in either direction between the two if specified in the
;;;             :   test.
;;; 2011.04.26 Dan
;;;             : * Use the millisecond times internally.
;;; 2011.04.28 Dan
;;;             : * Added some declaims and declares to avoid compiler warnings.
;;;             : * Suppress warnings about extending productions at initial load.
;;; 2011.08.23 Dan
;;;             : * Changed how get-buffer-index handles a direct request so that
;;;             :   they may to a + instead of a * for the validity table.  Doesn't
;;;             :   affect anything for compilation since productions with 
;;;             :   direct requests get pruned as invalid for compilation, but
;;;             :   other code which may use that index might care.
;;; 2011.09.13 Dan
;;;             : * Removed an errant debugging print out.
;;; 2012.04.04 Dan [1.5]
;;;             : * Added more detail to the compilation trace.  It now includes
;;;             :   a description of why a production was not valid for compilation
;;;             :   and will display the details reported by a buffer type if it
;;;             :   reports any.  A compilation type now has to specify whether
;;;             :   it has a whynot reason function which is the 9th parameter
;;;             :   passed to define-compilation-type.  If a whynot-reason function 
;;;             :   is specified it will be called with 3 parameters -- the p1 index
;;;             :   the p2 index and either the name of a test function which failed
;;;             :   or nil if no test function was called.
;;; 2012.11.20 Dan
;;;             : * Fixed a bug with how the comment string for the compiled production
;;;             :   was set when there's a dropout buffer which only occurs in the
;;;             :   conditions of the second production.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; General Docs:
;;; 
;;; Specific details of the production compilation process can be found in the
;;; compilation.doc file in the docs directory, but some general information about
;;; the mechanism is included here as well.
;;;
;;; The basic mechanism is that for any two productions that fire in sequence
;;; a new production may be created that is a composition of those two (typically
;;; referred to as "compiling" those productions).
;;;
;;; To determine whether two productions can be composed and how they get 
;;; composed depends on what buffers are used and how they are used.
;;;
;;; Here's the high-level algorithm in a text-based state chart (best
;;; viewed in a fixed width font):
#|
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                                                             start
                                                               |
                                                               V
                                                               |
                                                    -------------------------
        .--------------------.--------------------->| Wait for a production |
        |                    |                      -------------------------
        |                    |                                 |
        |                    |                                 V
        |                    |                                 |
        |                    |                      ------------------------- 
        |                    |                      | call it current       |
        |                    |                      -------------------------
        |                    |                                 |
        |                    |                                 V
        |                    ^                                 |
        |                    |                       /---------------------\
        |            ------------------             /  is current valid-p   \
        |            | clear previous | ------<--N- \                       / 
        |            ------------------              \---------------------/
        |                    |                                 | 
        |                    |                                 Y
        |                    |                                 |
        |                    ^                                 V
        |                    |                                 |
        ^                    N                                 |
        |                    |                      /---------------------\
----------------      /-----------\                /  is there a previous  \
| set previous |     / is current  \---------<--N- \                       /
| to current   |-<-Y-\ valid-1st-p /                \---------------------/
----------------      \-----------/                            |
                             |                                 | 
                             |                                 Y
                             |                                 |
                             |                                 |
                             ^                                 V
                             |                                 | 
                             |                       /---------------------\
                             |                      /   are previous and    \
                             +----------------<--N- \ current composable    /
                             |                       \---------------------/
                             |                                 | 
                             |                                 Y
                             |                                 |
                             ^                                 V
                             |                                 | 
                             |                      --------------------------
                             +----------------<---- | Compose new production |
                                                    --------------------------
|#

;;; The test for valid-p is that it have none of the following:
;;;    - LHS !eval!
;;;    - LHS !bind!
;;;    - LHS !safe-bind! (this is a precautionary stance for now)
;;;    - LHS !mv-bind!
;;;    - RHS !eval!
;;;    - RHS !bind!
;;;    - RHS !mv-bind!
;;;    - multiple LHS ='s for any one buffer.
;;;    - No direct requests 
;;;    - No slot modifiers other than = in the conditions.
;;;   
;;;
;;; The test for valid-1st-p is that it have none of the following:
;;;    - RHS !stop!
;;;    - more than one action of a particular type for a specific buffer of any style
;;;      though it may have a single modification, a single request, and a single modification request
;;;      for each buffer
;;;
;;; The test of composable is a lot more involved. 
;;; 
;;; First, the productions must fire within the threshold time of each other.
;;; Then, for each buffer used in either production the composition charts
;;; are consulted to determine if its useage is composeable.  If all of the buffers are
;;; composeable given their usage, there is a potential additional pass (only
;;; some buffer types require this check) to ensure that the buffer actions 
;;; in the first are compatible with the conditions in the second to avoid any 
;;; problems with an "unusual" change in the buffer.
;;;
;;; The default composition process considers buffers to fall into one of 5 general
;;; types (goal, imaginal, retrieval, perceptual, and motor) and the mechanism differs
;;; based on the types of buffers used in the two productions.  The Microsoft 
;;; Excel file "compilation.xls" in the docs directory lays out the tables that
;;; govern the composabilty of productions based on the types of buffers
;;; used and the conditions and actions they contain.  
;;;
;;; Here's a guide for how to read those sheets.  The A1 cell holds the 
;;; name of the compilation buffer type being specified.  B1 holds
;;; the function to call for mapping of constants to variables between
;;; the two productions' buffer usage or nil if no such mapping is necessary.
;;; C1 holds the function to call for creating the conditions and actions for 
;;; that buffer in the new production.  Cell D1 holds the name of a function to call for
;;; performing any extra compatibility test necessary after composability
;;; has been determined for the productions, or the value nil if there is
;;; no additional test necessary for this type.  Cell A2 is a list of the buffers 
;;; which will be set to this type, or the value :default if this should be the
;;; default type for any unspecified buffers. 
;;;
;;; The table in rows 5-45 specifies the conditions under which the
;;; usage of this buffer type in the two productions can be composed.
;;; The rows are for buffer usage in the first production and the
;;; columns are for the buffer's usage in p2.  The number is a
;;; reference used internally for representing the condition which
;;; is displayed symbolically in the table.  There are 6 ways which the
;;; buffer may be used in a production:
;;; 
;;; LHS test: =
;;; LHS query: ?
;;; RHS modification: =
;;; RHS explicit clear: -
;;; RHS request: +
;;; RHS modification request: *
;;;
;;; In the symbolic representation the > is used to separate lhs and rhs
;;; usage, a "." separates items on the same side and empty brackets {}
;;; indicates no usage of the buffer on that side.  Order doesn't
;;; matter since the production testing is considered in parallel and
;;; actions have a fixed priority regardless of the order in the production.
;;; Thus, =>=.+.* is a production with a lhs test of the buffer and then
;;; a modification, a request, and a modification request on the RHS.
;;;
;;; The cells of the table indicate whether or not productions with those
;;; particular usages can be composed.  If it is nil then they can not be.
;;; If it is t then they can without restrictions, and if it is any other
;;; value that names a function to call to test some additional constraint
;;; which must be met to compose those productions.  The description of
;;; those functions' operations are described below the table along with
;;; some additional comments about this type of buffer.
;;;
;;; The text files saved from those spreadsheets are used directly to 
;;; generate the buffer composition files found in the tools directory.
;;; The idea is that if one wants to either modify or extend the compilation
;;; mechanism, then that can be done by changing or adding new spreadsheets
;;; and then rebuilding or adding the corresponding composition file instead of
;;; having to recode the whole thing.  That may require also adding some new
;;; testing functions or composition functions, but it should not require
;;; changing the code or mechanisms in this file.
;;;   
;;; The default assignment of buffers to types based on the current
;;; spreadsheets is as follows (assuming that a buffer by that name exists):
;;;
;;; Buffer name           Type
;;;  goal              goal
;;;  imaginal          imaginal
;;;  retrieval         retrieval
;;;  visual-location   perceptual
;;;  visual            perceptual
;;;  aural-location    perceptual
;;;  aural             perceptual
;;;  manual            motor
;;;  vocal             motor
;;; 
;;; The default type is motor, thus any other buffer will be assumed to be of 
;;; type motor unless configured using the specify-compilation-buffer-type 
;;; command (which can also be used to change the types for the default buffer 
;;; assignments).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Public API:
;;; 
;;; defmacro specify-compilation-buffer-type (buffer-name buffer-type)
;;; defun   specify-compilation-buffer-type-fct (buffer-name buffer-type)
;;;
;;; buffer-name must be the name of a valid buffer in the model.
;;; buffer-type must be one of the symbols goal, retrieval, perceptual, motor.
;;;
;;; If the named buffer exists and the symbol for the buffer-type is valid this
;;; command will cause production compilation to treat the named buffer as a
;;; member of the specified type for composition purposes.
;;; 
;;; If the parameters are valid and there is a current production compilation
;;; module, then the command will return t otherwise it will print a warning 
;;; and return :error.
;;;
;;; If this command is to be used by a module to set its default type it
;;; should be done in the second module reset function.  If it is being set in
;;; the model, then it should occur within the body of the model.  Changing 
;;; the values at times other than reset or model creation are not advised and
;;; may lead to unpredictable behavior.
;;;
;;; defun show-compilation-buffer-types ()
;;;
;;; This command will print out a table showing the current compilation buffer
;;; type for all of the buffers in the system.  If there is no current module
;;; then it will print a warning.
;;; 
;;; It always returns nil.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Design Choices:
;;;
;;; Originally kept separate from the main procedural module as a precautionary
;;; measure while it was being developed, but now that separation seems like
;;; the right thing to do anyway to keep things clean.
;;;
;;; The dependence on and usage of the low-level production structure is not
;;; an ideal thing especially considering the option of extendability, but for
;;; now that's going to remain because it is convenient.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; The code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+:packaged-actr (in-package :act-r)
#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)
#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)

(declaim (ftype (function (t t t) t) update-utility-for-compiled-production))
(declaim (ftype (function (t) t) spp-fct))
(declaim (ftype (function (t t t) t) initialize-utility-for-compiled-production))

;;; Add a new parameter to productions to track who created it

(suppress-extension-warnings)

(extend-productions user-created :default-value t)


;;; Add a new parameter to productions for holding the bindings
;;; needed during compilation which might have temporary variables
;;; replacing the actual production variables

(extend-productions compilation-instan :default-value nil)


;;; Add a new parameter to hold any remapping of duplicate
;;; retrieval-style buffer names from p1->p2 to handle the
;;; proper mapping for instantiation their use in the 
;;; compiled production.

(extend-productions drop-out-buffers-map :default-value nil)


(extend-productions valid-1st-p :default-value :unset)
(extend-productions valid-for-compilation :default-value :unset)

(unsuppress-extension-warnings)

;;; Structure to hold a buffer-type's info instead of
;;; using separate tables.

(defstruct comp-buffer-type name (table (make-hash-table :test #'equalp)) compose map consistency buffers pre-instantiate drop-out whynot-reason)

;;; Globally store the possible composition types in a table
;;; where the key is the name and the value is a comp-buffer-type structure.
;;; The default type is also stored under the key nil.

(defvar *valid-compilation-buffer-types* (make-hash-table :test 'eq))

;;; Also store the reverse lookup of buffer to default type.

(defvar *buffer-to-compilation-type-table* (make-hash-table :test 'eq))


;;; Computed 

(defvar *buffer-var-names* nil
  "The variable names of all current buffers")

(defstruct compilation-module
  trace
  epl
  previous
  previous-time
  (buffer-type-table (make-hash-table))
  ppm
  tt
  (composeable-table (make-hash-table :test #'equalp)))


(defmacro define-compilation-type (name table buffers mapping compose consistency pre-instantiate drop-out whynot)
  `(define-compilation-type-fct ',name ',table ',buffers ',mapping ',compose ',consistency ',pre-instantiate ',drop-out ',whynot))



(defun define-compilation-type-fct (name table buffers mapping compose consistency pre-instantiate drop-out whynot)
  (cond ((or (> 1 (length (meta-process-names)))
             (not (eq (car (meta-process-names)) 'default)))
         (print-warning "Cannot create a new compilation type when there is a meta-process other than the default defined."))
        
        ((mp-models)
         (print-warning "Cannot create a new compilation type when there are models defined."))       
        
        ((gethash name *valid-compilation-buffer-types*)
         (print-warning "~s is already the name of a compilation type.  To redefine it it must first be removed with undefine-compilation-type." name))
        
        ((null name)
         (print-warning "Compilation type must have a non-nil name."))
        
        ((not (symbolp name))
         (print-warning "~s is not a symbol and thus not a valid compilation type name." name))
        
        ((keywordp name)
         (print-warning "A keyword is not valid as a compilation type name."))
        
        ((not (and compose (fctornil compose)))
         (print-warning "A compilation type must specify a compose function."))
        
        ((not (fctornil mapping))
         (print-warning "A compilation type must specify a valid function or nil for mapping."))
        
        ((not (fctornil consistency))
         (print-warning "A compilation type must specify a valid function or nil for consistency."))
        
        ((not (or (eq pre-instantiate t)
                  (fctornil pre-instantiate)))
         (print-warning "A compilation type must specify a valid function, t, or nil for pre-instantiate."))
        
        ((not (fctornil whynot))
         (print-warning "A compilation type must specify a valid function or nil for whynot."))
        
        ((not (or (null buffers)
                  (and (listp buffers) (every 'buffer-exists buffers))
                  (eq buffers :default)))
         (print-warning "Buffers must be a list of valid buffer names or the keyword :default"))
        
        ((not (and (listp table)
                   (every (lambda (x) (and (= 3 (length x)) (numberp (first x)) (numberp (second x)) (<= 0 (first x) 63) (<= 0 (second x) 63) (or (eq (third x) t) (fctornil (third x))))) table)))
         (print-warning "Invalid table for buffer type ~s.  All items must be 3 element lists of a p1 index, p2 index, and then either t, nil, or a function." name))
        
        (t
         (let ((type (make-comp-buffer-type :name name :buffers buffers :map mapping :compose compose :consistency consistency :pre-instantiate pre-instantiate :drop-out drop-out :whynot-reason whynot)))
           (setf (gethash name *valid-compilation-buffer-types*) type)
           
           ;; default type is also stored under the :default key
           
           (when (eq buffers :default)
             (setf (gethash :default *valid-compilation-buffer-types*) type))
           
           (if (listp buffers)
               (dolist (x buffers)
                 (setf (gethash x *buffer-to-compilation-type-table*) name))
             (dolist (x (buffers))
               (unless (gethash x *buffer-to-compilation-type-table*)
                 (setf (gethash x *buffer-to-compilation-type-table*) :default))))
           
           (dolist (x table)
             (setf (gethash (vector (first x) (second x)) (comp-buffer-type-table type)) (third x)))
           )
         name)))


(defmacro undefine-compilation-type (name)
  `(undefine-compilation-type-fct ',name))

(defun undefine-compilation-type-fct (name)
  (cond ((or (> 1 (length (meta-process-names)))
             (not (eq (car (meta-process-names)) 'default)))
         (print-warning "Cannot undefine a compilation type when there is a meta-process other than the default defined."))
        
        ((mp-models)
         (print-warning "Cannot undefine a compilation type when there are models defined."))       
        
        ((null name)
         (print-warning "Must specify the name of a compilation type to undefine."))
        
        ((not (gethash name *valid-compilation-buffer-types*))
         (print-warning "~s is not the name of a compilation type thus it cannot be undefined." name))
        
        (t
         (remhash name *valid-compilation-buffer-types*)
         
         ;; If it's the default type 
         (when (and (gethash :default *valid-compilation-buffer-types*)
                    (eq (comp-buffer-type-name (gethash :default *valid-compilation-buffer-types*)) name))
           (remhash :default *valid-compilation-buffer-types*))
         
         ;; don't worry about cleaning up *buffr-to-compilation-type-table* because
         ;; that will be tested later in module reset and appropriate warnings
         ;; can be issued.
         
         name)))


(defun create-composition-module (model-name)
  (declare (ignore model-name))
  
  ;; nothing extra needed now since the types are
  ;; created once when they're defined.
  
  (make-compilation-module))




(defun reset-production-compilation (instance)
  (setf (compilation-module-previous instance) nil)
  (setf (compilation-module-previous-time instance) 0)
  
  (clrhash (compilation-module-composeable-table instance))
  
  (clrhash (compilation-module-buffer-type-table instance))
  
  (setf *buffer-var-names* nil)
  
  (dolist (buffer (buffers))
    
    (push-last (intern (concatenate 'string "=" (string buffer))) *buffer-var-names*)
    
    (let ((standard (gethash buffer *buffer-to-compilation-type-table*)))
      (if (and standard (gethash standard *valid-compilation-buffer-types*))
          (setf (gethash buffer (compilation-module-buffer-type-table instance)) (gethash standard *valid-compilation-buffer-types*))
        (let ((default (gethash :default *valid-compilation-buffer-types*)))
          (if default
              (setf (gethash buffer (compilation-module-buffer-type-table instance)) default)
            (print-warning "No default compilation type available and buffer ~s does not have a type specified." buffer)))))))


(defun production-compilation-params (prod param)
  (cond ((consp param)
         (case (car param)
           
           (:pct (setf (compilation-module-trace prod) (cdr param)))
           (:tt 
            (setf (compilation-module-tt prod) (seconds->ms (cdr param)))
            (cdr param))
           (:epl (setf (compilation-module-epl prod) (cdr param)))
           (:ppm (setf (compilation-module-ppm prod) (cdr param)))))
        (t 
         (case param
           (:pct (compilation-module-trace prod))
           (:tt (ms->seconds (compilation-module-tt prod)))
           (:epl (compilation-module-epl prod))))))


(define-module-fct 'production-compilation
    nil
  (list (define-parameter :ppm :owner nil)
        (define-parameter :epl :default-value nil 
          :valid-test #'tornil :warning "T or nil"
          :documentation "Enable Production Learning")
        (define-parameter :pct :default-value nil 
          :valid-test #'tornil :warning "T or nil"
          :documentation "Production Compilation Trace")
        
        (define-parameter :tt :default-value 2.0
          :valid-test #'posnum :warning "a positive number"
          :documentation "Threshold time"))
  :version "1.5"
  :documentation "A module that assists the primary procedural module with compiling productions"
  :creation 'create-composition-module
  :reset 'reset-production-compilation
  :params 'production-compilation-params)



(defun compile-productions (production)
  (let ((module (get-module production-compilation))
        (p-name (production-name production)))
    
    (when (compilation-module-epl module)
      
      (when (compilation-module-trace module)
        (model-output "Production Compilation process started for ~s" p-name))
      
      (cond ((not (valid-compilation-production p-name production))
             (when (compilation-module-trace module)
               (model-output "  Production ~s is not valid for compilation" p-name)
               (model-output "   because ~a" (invalid-compilation-reason production)))
             (setf (compilation-module-previous module) nil))
            
            ((null (compilation-module-previous module))
             (when (compilation-module-trace module)
               (model-output "  No previous production to compose with."))
             (handle-check-valid-1st-p module p-name production))
            ((> (- (mp-time-ms) (compilation-module-previous-time module))
                (compilation-module-tt module))
             (when (compilation-module-trace module)
               (model-output "  Cannot compile ~s and ~s because the time between them exceeds the threshold time."
                             (car (compilation-module-previous module))
                             p-name))
             (handle-check-valid-1st-p module p-name production))
            ((null (composeable-productions-p module (get-production (car (compilation-module-previous module))) production))
             (when (compilation-module-trace module)
               (model-output "  Production ~s and ~s cannot be composed." (car (compilation-module-previous module)) p-name))
             (handle-check-valid-1st-p module p-name production))
            (t
             (when (compilation-module-trace module)
               (model-output "  Production ~s and ~s are being composed." (car (compilation-module-previous module)) p-name))
             (compose-productions module production)
             (handle-check-valid-1st-p module p-name production))))))



(defun valid-compilation-production (p-name prod)
  (let ((v (production-valid-for-compilation p-name)))
    (if (eq :unset v)
        (setf (production-valid-for-compilation p-name)
          (not (or (find 'eval (production-lhs prod) :key #'cdar)
                   (find 'eval (production-rhs prod) :key #'cdar)
                   (find 'bind (production-lhs prod) :key #'cdar)
                   (find 'bind (production-rhs prod) :key #'cdar)
                   (find 'mv-bind (production-lhs prod) :key #'cdar)
                   (find 'mv-bind (production-rhs prod) :key #'cdar)
                   (find 'safe-bind (production-lhs prod) :key #'cdar)
                   (check-for-duplicates #\= (production-lhs prod))
                   (issues-direct-requests prod)
                   (slot-modifers-other-than-= prod)
                   (redundant-variable-check prod))))
      v)))


(defun invalid-compilation-reason (prod)
  (cond ((or (find 'eval (production-lhs prod) :key #'cdar)
             (find 'eval (production-rhs prod) :key #'cdar))
         "it contains one or more !eval! operators")
        ((or (find 'bind (production-lhs prod) :key #'cdar)
             (find 'bind (production-rhs prod) :key #'cdar)
             (find 'mv-bind (production-lhs prod) :key #'cdar)
             (find 'mv-bind (production-rhs prod) :key #'cdar))
         "it contains one or more !bind! operators")
        ((find 'safe-bind (production-lhs prod) :key #'cdar)
         "it contains one or more LHS !safe-bind! operators")
        ((check-for-duplicates #\= (production-lhs prod))
         (format nil "it has multiple LHS conditions for the ~a buffer" (duplicate-buffer-name #\= (production-lhs prod))))
        ((issues-direct-requests prod)
         (format nil "it makes a direct request to the ~a buffer" (direct-request-buffer-name prod)))
        ((slot-modifers-other-than-= prod)
         "it has conditions with modifiers on slot tests")
        (t ;;(redundant-variable-check prod) -- that always returns nil and prints a warning now
         "of unknown reason. (This should not happen. Please report this issue to Dan.)")))

(defun check-for-duplicates (char items)
  (let ((filtered (mapcar #'cdar 
                    (remove char items :key #'caar 
                            :test #'(lambda (x y)
                                      (not (eql x y)))))))
    (not (= (length filtered) 
            (length (remove-duplicates filtered))))))


(defun duplicate-buffer-name (char items)
  (let ((filtered (mapcar #'cdar 
                    (remove char items :key #'caar 
                            :test #'(lambda (x y)
                                      (not (eql x y)))))))
    (car (remove-if-not (lambda (x) (> (count x filtered) 1)) filtered))))


(defun issues-direct-requests (prod)
  (let ((rep (produce-standard-representation prod)))
    (find-if #'(lambda (y) 
                 (unless (eq (first y) '!output!)
                   (let ((x (second y)))
                     (and (= (length x) 1)
                          (not (listp (first x)))))))
             (second rep))))

(defun direct-request-buffer-name (prod)
  (let* ((rep (produce-standard-representation prod))
         (request (find-if #'(lambda (y) 
                               (unless (eq (first y) '!output!)
                                 (let ((x (second y)))
                                   (and (= (length x) 1)
                                        (not (listp (first x)))))))
                           (second rep)))
         (buffer-action (princ-to-string (car request))))
    (subseq buffer-action 1 (1- (length buffer-action)))))

(defun slot-modifers-other-than-= (prod)
  (let ((rep (produce-standard-representation prod)))
    (dolist (condition (first rep))
      (unless (or (eq (car condition) '!safe-eval!)
                  (eq (car condition) '!safe-bind!))
        
        (dolist (tests (second condition))
          (when (and (listp tests)
                     (= (length tests) 3)
                     (not (eql '= (car tests))))
            (return-from slot-modifers-other-than-= t)))))))


(defun redundant-variable-check (prod)
  (let ((rep (produce-standard-representation prod)))
    (dolist (condition (first rep) nil)
      (when (char= #\= (aref (symbol-name (car condition)) 0))
        (let ((tests (remove-duplicates (remove-if-not 'chunk-spec-variable-p (cdadr condition) :key 'third))))
          ;(format t "Condition: ~S: ~S~%" condition tests)
          (dolist (slot tests)
            (when (> (count (second slot) tests :key #'second) 1)
              (print-warning "Production ~s has redundant variables in the conditions which may lead to unusual production compilation results." (production-name prod))
              (return-from redundant-variable-check nil))))))))

;;; The test for valid-1st-p is that it have none of the following:
;;;    - RHS !stop!
;;;    - multiple <buffer> actions of the same type for a single buffer of any style
;;;      i.e. there can be at most one modification, one request, and one modification
;;;      request per buffer.

(defun valid-1st-p (p-name prod)
  (let ((v (production-valid-1st-p p-name)))
    (if (eq :unset v)
        (setf (production-valid-1st-p p-name)
          (not (or (find 'stop (production-rhs prod) :key #'cdar)
                   (check-for-duplicates #\= (production-rhs prod))
                   (check-for-duplicates #\+ (remove-if (lambda (x) (eq 'isa (caadr x))) (production-rhs prod)))
                   (check-for-duplicates #\+ (remove-if-not (lambda (x) (eq 'isa (caadr x))) (production-rhs prod))))))
      v)))


(defun invalid-1st-p-reason (prod)
  (cond ((find 'stop (production-rhs prod) :key #'cdar)
         "it has a !stop! action")
        ((check-for-duplicates #\= (production-rhs prod))
         (format nil "it has multiple modification actions for the ~a buffer" (duplicate-buffer-name #\= (production-rhs prod))))
        
        ((check-for-duplicates #\+ (remove-if (lambda (x) (eq 'isa (caadr x))) (production-rhs prod)))
         (format nil "it has multiple requests to the ~a buffer" (duplicate-buffer-name #\+ (remove-if (lambda (x) (eq 'isa (caadr x))) (production-rhs prod)))))
        ((check-for-duplicates #\+ (remove-if-not (lambda (x) (eq 'isa (caadr x))) (production-rhs prod)))
         (format nil "it has multiple modification requests to the ~a buffer" (duplicate-buffer-name #\+ (remove-if-not (lambda (x) (eq 'isa (caadr x))) (production-rhs prod)))))
        (t
         "of unknown reason. (This should not happen. Please report this issue to Dan.)")))
 
(defun handle-check-valid-1st-p (module p-name prod)
  (if (valid-1st-p p-name prod)
      (progn
        (setf (compilation-module-previous module)
          (list (production-name prod)
                (copy-tree (production-bindings prod))))
        (setf (compilation-module-previous-time module) (mp-time-ms))
        (when (compilation-module-trace module)
          (model-output "  Setting previous production to ~S." (production-name prod))))
    (progn
      (when (compilation-module-trace module)
        (model-output "  Production ~s is not valid as a first production for compilation" (production-name prod))
        (model-output "   because ~a" (invalid-1st-p-reason prod)))
      (setf (compilation-module-previous module) nil))))



(defun composeable-productions-p (module p1 p2)
  (multiple-value-bind (val exists)
      (gethash (vector (production-name p1) (production-name p2)) (compilation-module-composeable-table module))
    
    (if exists 
        (cond
         ((eq val t)
          t)
         ((listp val)
          (when (compilation-module-trace module)
            (if (first val)
                (model-output "  Buffer ~S prevents composition of these productions~@[~%   because ~a~]" (first val) (second val))
              (model-output "  ~a prevents composition of these productions" (second val)))))
         (t
          (print-warning "Invalid value in composeable table -- contact Dan.")))
      (let ((val (determine-composable module p1 p2)))
        (setf (gethash (vector (production-name p1) (production-name p2)) (compilation-module-composeable-table module)) val)
        (if (eq val t) t nil)))))


(defun determine-composable (module p1 p2)
  
  (dolist (buffer (remove-duplicates (append (production-lhs-buffers p1)
                                             (production-lhs-buffers p2)
                                             (production-rhs-buffers p1)
                                             (production-rhs-buffers p2))))
    
    (let* ((type (gethash buffer (compilation-module-buffer-type-table module)))
           (table (comp-buffer-type-table type))
           (p1-usage (get-buffer-index p1 buffer))
           (p2-usage (get-buffer-index p2 buffer))
           (index (vector p1-usage p2-usage))
           (value (gethash index table)))
      
      (unless (and value 
                   (or (eq value t) (funcall value buffer p1 p2)))
        (let ((reason (awhen (comp-buffer-type-whynot-reason type)
                             (funcall it p1-usage p2-usage (and (not (eq value t)) value)))))
          (when (compilation-module-trace module)
            (model-output "  Buffer ~S prevents composition of these productions~@[~%   because ~a~]" buffer reason)
            )
          (return-from determine-composable (list buffer reason))))))
  
  
  (dolist (buffer (intersection (production-rhs-buffers p1)
                                (production-lhs-buffers p2)) t)
    (let ((type (gethash buffer (compilation-module-buffer-type-table module))))
      (when (comp-buffer-type-consistency type)
        (unless (funcall (comp-buffer-type-consistency type) buffer module p1 p2)
          (model-output "  A failed consistency test for buffer ~a prevents composition of these productions" buffer)
          (return-from determine-composable (list nil (format nil "A failed consistency test for buffer ~a" buffer))))))))


(defun check-consistency (module action action-bindings condition cond-bindings &key allow-subtypes)
  (cond ((consp (car action)) ;; it's a +
         
         (let* ((action-spec (define-chunk-spec-fct (replace-variables (second action) action-bindings)))
                (action-map (chunk-spec-slot-spec action-spec))
                (cond-spec (third condition))
                (cond-map (replace-variables (fifth condition) cond-bindings))
                (action-type (chunk-spec-chunk-type action-spec))
                (cond-type (chunk-spec-chunk-type cond-spec)))
           
           (unless (or (eq action-type cond-type)
                       (and allow-subtypes 
                            (or (chunk-type-subtype-p-fct action-type cond-type)
                                (chunk-type-subtype-p-fct cond-type action-type))))
                                
             (return-from check-consistency nil))
           
           (unless (compilation-module-ppm module)
             (dolist (cond cond-map)
               (let ((action (find (second cond) action-map :test #'(lambda (x y)
                                                                      (and (eq (first y) '=)
                                                                           (eq (second y) x))))))
                 (when action
                   (unless (chunk-slot-equal (third cond) (third action))
                     (return-from check-consistency nil))))))))
        (t ; this is the  = case
         
         (let* ((action-spec (define-chunk-spec-fct (replace-variables (append (list 'isa (car action)) (third action)) action-bindings)))
                (action-map (chunk-spec-slot-spec action-spec))
                (cond-spec (third condition))
                (cond-map (replace-variables (fifth condition) cond-bindings))
                (action-type (car action))
                (cond-type (chunk-spec-chunk-type cond-spec)))
           
           (unless (or (eq action-type cond-type)
                       (and allow-subtypes 
                            (or (chunk-type-subtype-p-fct action-type cond-type)
                                (chunk-type-subtype-p-fct cond-type action-type))))
             (return-from check-consistency nil))
           
           (unless (compilation-module-ppm module)
             (dolist (cond cond-map)
               (let ((action (find (second cond) action-map :test #'(lambda (x y)
                                                                      (and (eq (first y) '=)
                                                                           (eq (second y) x))))))
                 (when action
                   (unless (chunk-slot-equal (third cond) (third action))
                     (return-from check-consistency nil)))))))))
  t)



(defun get-buffer-index (production buffer)
  (unless (production-buffer-indices production)
    (setf (production-buffer-indices production)
      (mapcar #'(lambda (buffer) (cons buffer 0))
        (remove-duplicates (append (get-buffers (production-lhs production))
                                   (get-buffers (production-rhs production))))))
    (dolist (x (production-buffer-indices production))
      (when (find (cons #\= (car x)) (production-lhs production) :key #'car :test #'equal)
        (incf (cdr x) 8))
      (when (find (cons #\? (car x)) (production-lhs production) :key #'car :test #'equal)
        (incf (cdr x) 16))
      (when (find (cons #\= (car x)) (production-rhs production) :key #'car :test #'equal)
        (incf (cdr x) 1))
      (when (find (cons #\- (car x)) (production-rhs production) :key #'car :test #'equal)
        (incf (cdr x) 2))
      (when (find (cons #\+ (car x)) (production-rhs production) :key #'car :test #'equal)
        (let ((all (remove-if-not (lambda (y) (equal (cons #\+ (car x)) (car y))) (production-rhs production))))
          (when (or (find 'isa all :key #'caadr) (find-if (lambda (x) (= (length (second x)) 1)) all))
            (incf (cdr x) 4))
          (when (find 'isa (remove-if (lambda (x) (= (length (second x)) 1)) all) :key #'caadr :test #'neq)
            (incf (cdr x) 32))))))
  
  (aif (cdr (assoc buffer (production-buffer-indices production)))
       it
       0))

(defun get-buffers (items)
  (let ((res nil))
    (dolist (x items res)
      (unless (eq #\! (caar x))
        (push (cdar x) res)))))



(defun get-compilation-type-struct (buffer module)
  (gethash buffer (compilation-module-buffer-type-table module)))


(defun compose-productions (module p2)
  ;(print-warning "Composition process not yet operational")
  
  (let* ((p1 (get-production (first (compilation-module-previous module))))
         (p1-s (produce-standard-representation p1))
         (p2-s (produce-standard-representation p2))
         (p1-variables (production-variables p1))
         (p2-variables (production-variables p2))
         (p1-basic-vars (remove-buffers p1-variables))
         (p2-basic-vars (remove-buffers p2-variables))
         (p2-name (production-name p2))
         (new-bindings nil))
    
    (setf (production-compilation-instan p2-name) (production-bindings p2))
    
    (awhen (intersection p1-basic-vars p2-basic-vars)
           (multiple-value-setq (p2-s new-bindings) 
             (rename-variables p2-s it (union p1-basic-vars p2-basic-vars)))
           
           (setf (production-compilation-instan p2-name) 
             (replace-variables (production-compilation-instan p2-name) new-bindings))
           
           (setf (production-drop-out-buffers-map p2-name)
             (remove-if-not (lambda (x) (find x *buffer-var-names*))
                            new-bindings  :key #'car)))
    
    
    ;; To allow for proper mapping of variables and values between
    ;; p1 and p2 it may be necessary to instantiate slot name variables
    ;; in dynamic productions.
    ;;
    ;; This should only be necessary if a buffer allows for modifications on
    ;; the RHS of p1 which could be carried over to the conditions of p2 for now, but
    ;; there may be other conditions that are discovered in the future.
    ;;
    ;; The compilation type needs to indicate if that is possible and may also
    ;; specify a constraint on when to allow it to happen (which presumably is
    ;; just for efficency because conditional application of this for other 
    ;; reasons could lead to unusual results in the newly composed production).
    ;;
    
    
    ;(pprint p1-s)
    ;(pprint p2-s)
    
    (dolist (b (production-buffer-indices p1))
      (let* ((comp-type (get-compilation-type-struct (car b) module))
             (instantiate (comp-buffer-type-pre-instantiate comp-type)))
        
        (when (and instantiate (or (eq instantiate t) (funcall instantiate b p2)))
          
          (let* ((b= (intern (concatenate 'string "=" (string (car b)) ">")))
                 (b+ (intern (concatenate 'string "+" (string (car b)) ">")))
                 (c2 (copy-tree (find b= (first p2-s) :key #'car)))
                 (a1= (copy-tree (find b= (second p1-s) :key #'car)))
                 (a1* (copy-tree (aif (find b+ (second p1-s) :key #'car)
                                      (if (eq 'isa (caaadr it))
                                          it nil)
                                      nil)))
                 (mod-vars (append (mapcan (lambda (x)
                                             (when (chunk-spec-variable-p (car x))
                                               (list (car x))))
                                     (cadr a1=))
                                   (mapcan (lambda (x)
                                             (when (chunk-spec-variable-p (car x))
                                               (list (car x))))
                                     (cadr a1*))))
                 (cond-vars (mapcan (lambda (x)
                                      (when (chunk-spec-variable-p (second x))
                                        (list (second x))))
                              (cdadr c2))))
            
            ;
            ;(pprint b=)
            ;(pprint c2)
            ;(pprint (cdadr c2))
            ;(pprint a1=)
            
            ;(pprint mod-vars)
            ;(pprint cond-vars)
            
            ;(pprint (second (compilation-module-previous 
            ;                 (get-module production-compilation))))
            ;(pprint p2-instans)
            
            
            (cond ((and mod-vars cond-vars)
                   (let* ((p1-instantiations (second (compilation-module-previous 
                                                      (get-module production-compilation))))
                          
                          
                          (s1 (remove-if-not (lambda (x) (find x mod-vars)) p1-instantiations :key #'car))
                          (s2 (remove-if-not (lambda (x) (find x cond-vars)) (production-compilation-instan p2-name) :key #'car)))
                     
                     (dolist (mv s1)
                       (dolist (cv (remove-if-not (lambda (x) (eq (cdr mv) x)) s2 :key #'cdr))
                         
                         (setf p1-s (replace-variables-special p1-s (list mv)))
                         (setf p2-s (replace-variables-special p2-s (list cv)))))))
                  ((and mod-vars (cdadr c2))  ;; variables in the modification and any slots tested in c2
                   (let* ((p1-instantiations (second (compilation-module-previous 
                                                      (get-module production-compilation))))
                          
                          
                          (s1 (remove-if-not (lambda (x) (find x mod-vars)) p1-instantiations :key #'car)))
                     
                     (dolist (mv s1)
                       (setf p1-s (replace-variables-special p1-s (list mv))))))
                  (cond-vars
                   (let ((s2 (remove-if-not (lambda (x) (find x cond-vars)) (production-compilation-instan p2-name) :key #'car)))
                     (dolist (cv s2)
                       (setf p2-s (replace-variables-special p2-s (list cv)))))))))))
    
    ;(pprint p1-s)
    ;(pprint p2-s)
    
    (let* ((mappings nil)
           (ppm (compilation-module-ppm module))
           (bindings (when ppm 
                     (append (second (compilation-module-previous module))
                             (production-compilation-instan (production-name p2))))))
      
      (dolist (buffer (union (mapcar #'car (production-buffer-indices p1))
                             (mapcar #'car (production-buffer-indices p2))))
        ;(pprint buffer)
        (let* ((comp-type (get-compilation-type-struct buffer module))
               (map-fn (comp-buffer-type-map comp-type)))
          
          (when map-fn
             (setf mappings (append (funcall map-fn module p1 p1-s p2 p2-s buffer) mappings)))
        ;(pprint mappings)
        ))
      
      ;(pprint mappings)
      
      ;;; Current mechanism for !safe-bind! on the RHS of P1 is to
      ;;; add its binding as a constant value and drop the bind.
            
      ;;; Here we add the binding to the mappings
      
      (dolist (x (second p1-s))
        (when (eq (car x) '!safe-bind!)
          ;(pprint x)
          (push-last (assoc (car (second x)) 
                            (second (compilation-module-previous module)))
                     mappings)
          ;(pprint 'variables)
          (dolist (y (find-variables (cdr (second x))))
            (push-last (assoc y (second (compilation-module-previous module)))
                       mappings))
          ;(pprint 'not-variables)
          ))
      
      
      (setf mappings (remove-duplicates mappings))
      (setf mappings (sort mappings #'< :key #'(lambda (x)
                                                 (if (constant-value-p (cdr x))
                                                     (if (constant-value-p (car x))
                                                         1 
                                                       2)
                                                   0))))
      
      
      ;(pprint mappings)
      ;(pprint p1-s)
      ;(pprint p2-s)
      
      (loop
        (let* ((mapping (pop mappings))
               (const (and ppm (constant-value-p (cdr mapping)))))
          (when (null mapping) (return))
          
          
          (when const
            (awhen (find (car mapping) bindings :key 'car)
                   ;(format t "Changing mapping from :~s to: ~S~%" mapping it)
                   (setf mapping it)))
          
          ;; this doesn't replace constants which is a good thing...
          
          (setf p1-s (replace-variables-special p1-s (list mapping)))
          (setf p2-s (replace-variables-special p2-s (list mapping)))
          
         ; (pprint const)
          
          
          (dolist (x mappings)
            ;  Don't want to do any constant to constant substitutions...
            ;  at least not with current plans
            ;(if const
             ;   (cond ((and (eq (car x) (car mapping)) (eq (cdr x) (car mapping))) ;; crazy case, but better be safe
             ;          (pprint 1)
             ;          (replace mappings (list (cons (cdr mapping) (cdr mapping))) :start1 (position x mappings :test #'equal)))
             ;         ((eq (car x) (car mapping))
             ;          (pprint 2)
             ;          (replace mappings (list (cons (cdr mapping) (cdr x))) :start1 (position x mappings :test #'equal)))
             ;         ((eq (cdr x) (car mapping))
             ;          (pprint 3)
             ;          (replace mappings (list (cons (car x) (cdr mapping))) :start1 (position x mappings :test #'equal)))
             ;         )
              (when (eq (car x) (car mapping))
                (replace mappings (list (cons (cdr mapping) (cdr x))) :start1 (position x mappings :test #'equal)))
            ;  )
            )
          
         ; (pprint mapping)
         ; (pprint p1-s)
          ;(pprint p2-s)
          ))
      
      ;(pprint p1-s)
      ;(pprint p2-s)
      
      (let ((p3-s (list nil nil)))
        (dolist (buffer (union (mapcar #'car (production-buffer-indices p1))
                               (mapcar #'car (production-buffer-indices p2))))
          
          ;(pprint buffer)
          
          (let* ((comp-type (get-compilation-type-struct buffer module))
                 (compose-fn (comp-buffer-type-compose comp-type)))
          
          (when compose-fn
             (let ((vals (funcall compose-fn p1 p1-s p2 p2-s buffer)))
                 ;(pprint it)
                 ;(pprint vals)
                 (setf (first p3-s) (append (first p3-s) (first vals)))
                 (setf (second p3-s) (append (second p3-s) (second vals)))))))
        
        
        ;; Copy over anything that isn't a buffer reference
        
        ;; Making sure that the p1 stuff comes before the
        ;; p2 stuff in the new production (since it's being
        ;; pushed it must go backwards)
        
        
        (dolist (x (first p2-s))
          (when (find (car x) '(!safe-eval!))
            (push x (first p3-s))))
        
        ;;; need to make sure binds come before evals from the p2 stuff
        ;;; so just do it as a quick and dirty two pass now
        ;;; original order might be nice, but this should handle things
        ;;; for now since that gets munged in the standard rep...
        
        (dolist (x (second p2-s))
          (when (find (car x) '(!safe-bind!))
            (push x (second p3-s))))
        
        (dolist (x (second p2-s))
          (when (find (car x) '(!safe-eval! !output!))
            (push x (second p3-s))))
        
        
        (dolist (x (first p1-s))
          (when (find (car x) '(!safe-eval!))
            (unless (find x (first p3-s) :test #'equal)
              (push x (first p3-s)))))
        
        ;;; Here's where we remove the bind.
        
        (dolist (x (second p1-s))
          (when (find (car x) '(#|!safe-bind!|# !safe-eval! !output! !stop!))
            (unless (find x (second p3-s) :test #'equal)
              (push x (second p3-s)))))
        
        
        ;(pprint p3-s)
        
        ;; Double check that everything gets bound 
        ;; The assumption being that it had to come from the second
        ;; production to get lost (through a retrieval removal or 
        ;; colapsing of conditions).  So, just replace it with
        ;; the instantiated value from p2 if there are any.
        
        (let ((lhs-vars (find-variables (mapcar #'cdr (first p3-s))))
              (rhs-vars (find-variables (mapcar #'cdr (second p3-s))))
              (rhs-bindings (mapcar #'caadr (remove '!safe-bind! (second p3-s) :test-not #'eql :key #'car))))
          
          ; (pprint lhs-vars)
          ; (pprint rhs-vars)
          ; (pprint rhs-bindings)
          
          (dolist (v rhs-vars)
            (unless (or (find v *buffer-var-names*) ;; don't want to bind the buffer refs...
                        (find v lhs-vars)
                        (find v rhs-bindings)
                        )
              
              ;(pprint v)
              (setf (second p3-s) (replace-variables (second p3-s) (list (assoc v (production-compilation-instan p2-name))))))))
        
        
        ;(pprint p3-s)
        
        (let ((post-conditions nil)
              (new-p nil)
              (dynamic nil))
          
          
          (push (new-production-name) new-p)
          
          (push (format nil "~A & ~A~{~@[ - ~a~]~}"
                  (production-name p1) (production-name p2)
                  (mapcan #'(lambda (x)
                              (let ((comp-type (get-compilation-type-struct x module)))
                                (when (and (comp-buffer-type-drop-out comp-type)
                                           (numberp (cdr (assoc x (production-buffer-indices p1))))
                                           (not (zerop (logand (cdr (assoc x (production-buffer-indices p1))) 4))))  ;; require the request bit be set in the first production's usage
                                  (list (aif (chunk-copied-from-fct (cdr (assoc (read-from-string (format nil "=~a" x)) (production-bindings p2))))
                                             it
                                             (cdr (assoc (read-from-string (format nil "=~a" x)) (production-bindings p2))))))))
                    (production-lhs-buffers p2)))
                new-p)
          
          (dolist (condition (sort-conditions (first p3-s)))
            
            ;(pprint condition)
            
            (if (find (car condition) '(!safe-bind! !safe-eval! !output! !stop!))
                (progn
                  (push (car condition) post-conditions)
                  (push (first (second condition)) post-conditions))
              
              (progn
                (push (car condition) new-p)
                (dolist (test (second condition))
                  (when (and (= (length test) 3)
                             (chunk-spec-variable-p (second test)))
                    (setf dynamic t))
                  
                  (dolist (x (if (and (= (length test) 3)
                                      (eq (car test) '=))
                                 (cdr test)
                               test))
                    (push x new-p)))))
            )
          
          
          (when post-conditions
            (setf new-p (append post-conditions new-p)))
          
          
          (push '==> new-p)
          
          
          (dolist (action (sort-actions (second p3-s)))
            
            ;(pprint action)
            
            (push (car action) new-p)
            
            
            
            (cond ((find (car action) '(!safe-eval! !output!))
                   (push (first (second action)) new-p))
                  ((eq (car action) '!safe-bind!)
                   (push (first (second action)) new-p)
                   (push (second (second action)) new-p))
                  ((null (second action))
                   )
                  ((and (= (length (second action)) 1)
                        (not (listp (first (second action)))))
                   (push (first (second action)) new-p))
                  (t
                   (dolist (test (second action))
                     
                     (when (or (and (= (length test) 3)
                                    (chunk-spec-variable-p (second test)))
                               (and (= (length test) 2)
                                    (chunk-spec-variable-p (first test))))
                       (setf dynamic t))
                     
                     (dolist (x (if (and (= (length test) 3)
                                         (eq (car test) '=))
                                    (cdr test)
                                  test))
                       (push x new-p))))))
          
          ;(pprint (reverse new-p))
          
          (let ((procedural (get-module procedural)))
            (setf (procedural-delay-tree procedural) t)
            
            (let* ((new-prod (if (and (or (production-dynamic p1) (production-dynamic p2)) dynamic) ;; double-check
                                 (with-unchecked-p* (p*-fct  (reverse new-p)))
                               (p-fct (reverse new-p))))
                   (p3 (get-production new-prod)))
              (setf (procedural-delay-tree procedural) nil)
              
              (when p3
                (update-params-for-compiled-production p3 new-prod p1 p2 module procedural)))))))))


(defun update-params-for-compiled-production (p3 new-prod p1 p2 module procedural)
  (let ((exists (check-for-duplicate-productions new-prod)))
    
    (cond ((null exists)
           ;; New production 
           (when (compilation-module-trace module)
             (model-output "  New production:~%")
             (when (car (no-output (sgp :v)))
               (print-production p3 t)))
           
           ; add it to the tree since that was suppressed
           (when (and (procedural-use-tree procedural) (not (procedural-delay-tree procedural)))
             (add-production-to-tree p3 procedural))
           
           ;mark it as a compiled productions
           
           (setf (production-user-created new-prod) nil)
           
           ; initialize-stats for new-prod
           
           (initialize-utility-for-compiled-production new-prod (production-name p1) (production-name p2))
           
           (when (and (compilation-module-trace module)
                      (car (no-output (sgp :v))))
             (spp-fct (list new-prod))))
          
          ((null (production-user-created exists))
           
           ;; recreation of a previously compiled
           
           (when (compilation-module-trace module)
             (model-output "  Recreating production ~a" exists))
           
           (setf (procedural-delay-tree procedural) t)
           (delete-production new-prod)
           (release-name-fct new-prod)
           (setf (procedural-delay-tree procedural) nil)
           
           (update-utility-for-compiled-production exists (production-name p1) (production-name p2))
           
           (when (and (compilation-module-trace module)
                      (car (no-output (sgp :v))))
             (spp-fct (list exists))))
          
          (t 
           ;;recreation of a user production
           
           (when (compilation-module-trace module)
             (model-output "  Result is production ~a~%  No actions taken." exists)) 
           
           (setf (procedural-delay-tree procedural) t)
           (delete-production new-prod)
           (release-name-fct new-prod)
           (setf (procedural-delay-tree procedural) nil)))))

(defun new-production-name ()
  (loop (let ((name (new-name production)))
          (unless (get-production name)
            (return name)))))


(defun replace-variables-special (arg bindings)
  (let ((res (list nil nil)))
    (dolist (x (first arg))
      (push-last  (if (or (eql (car x) '!safe-eval!)
                          (eql (car x) '!safe-bind!))
                      (replace-variables-for-eval x bindings)
                    (replace-variables x bindings))
                 (first res)))
    (dolist (x (second arg))
      (push-last  (if (or (eql (car x) '!safe-eval!)
                          (eql (car x) '!safe-bind!))
                      (replace-variables-for-eval x bindings)
                    (replace-variables x bindings))
                 (second res)))
    res))



(defun sort-conditions (conditions-list)
  (let ((new-conditions (copy-tree conditions-list)))
    ;(pprint new-conditions)
    (sort new-conditions #'string< :key #'(lambda (x)
                                            (let ((val (string (car x))))
                                              (if (eql #\! (aref val 0))
                                                  "z"
                                                val))))))

(defun sort-actions (actions-list)
  (let ((new-actions (copy-tree actions-list)))
    (stable-sort new-actions #'string> :key (lambda (x) (string (car x))))))

(defun check-for-duplicate-productions (prod-name)
  (let ((p (get-production prod-name)))
    (dolist (old-p (all-productions) nil)
      (unless (equal old-p prod-name)
        (when (equivalent-productions-p (get-production old-p) p)
          (return-from check-for-duplicate-productions old-p))))))



(defun equivalent-productions-p (p1 p2)
  ;; Check the easy stuff first to
  ;; hopefully be faster
  
  (unless (production-buffer-indices p1)
    (get-buffer-index p1 nil))
  (unless (production-buffer-indices p2)
    (get-buffer-index p2 nil))
  
  
  (when (and (= (length (remove-buffers (production-variables p1)))
                (length (remove-buffers (production-variables p2))))
             (= (length (production-lhs p1))
                (length (production-lhs p2)))
             (= (length (production-rhs p1))
                (length (production-rhs p2)))
             (equal (production-buffer-indices p1)
                    (production-buffer-indices p2)))
    
    (let ((mappings1 (mapcar #'(lambda (x) (cons x '&&dummy&&))
                       (remove-buffers (production-variables p1))))
          (mappings2 (mapcar #'(lambda (x) (cons x '&&dummy&&))
                       (remove-buffers (production-variables p2))))
          (s1 (produce-standard-representation p1))
          (s2 (produce-standard-representation p2)))
      
      
      
      ;; Check the overall structure 
      (unless (= (length (union (replace-variables (copy-tree s1) mappings1)
                                (replace-variables (copy-tree s2) mappings2) :test #'equalp))
                 (length s1))
        
        (return-from equivalent-productions-p nil))
      
      
      
      (setf mappings1 (mapcar #'(lambda (x) (replace-variables (copy-tree s1) (cons (cons (car x) '&&VAR&&) (remove (car x) mappings1 :key #'car))))
                        mappings1))
      (setf mappings2 (mapcar #'(lambda (x) (replace-variables (copy-tree s2) (cons (cons (car x) '&&VAR&&) (remove (car x) mappings2 :key #'car))))
                        mappings2))
      
      
      ;;; Fix the issue with differently "ordered" productions not showing as equivalent i.e.
      ;;; (p test1 =goal> isa count-from count =a count =b !eval! (pprint =a) ==> =goal> end =b)
      ;;; (p test2 =goal> isa count-from count =b count =a !eval! (pprint =b) ==> =goal> end =a)
      
      (setf mappings1 (remove-unneeded-variables mappings1))
      (setf mappings2 (remove-unneeded-variables mappings2))
      
      
      (unless (= (length (union mappings1 mappings2 :test #'equalp))
                 (length mappings1))
        (return-from equivalent-productions-p nil))
      
      t)))


(defun remove-unneeded-variables (mapping)
  (let ((res nil))
    (dolist (var mapping)
      (let ((conds nil)
            (acts nil))
        (dolist (x (first var))
          (when (recursive-find '&&VAR&& x)
            (push
             (case (aref (string (car x)) 0)
               (#\! x)
               (t
                (list (car x) (remove-if-not #'(lambda (y)
                                                 (find '&&VAR&& y))
                                             (second x)))))
             conds)))
        (dolist (x (second var))
          (when (recursive-find '&&VAR&& x)
            (push
             (case (aref (string (car x)) 0)
               (#\! x)
               (t
                (list (car x) (remove-if-not #'(lambda (y)
                                                 (find '&&VAR&& y))
                                             (second x)))))
             acts)))
        (push (list conds acts) res)))
    res))



(defun get-buffer-composition-type (buffer)
  (aif (get-module production-compilation)
       (aif (gethash buffer (compilation-module-buffer-type-table it))
            it
            (print-warning "No type for buffer ~S found" buffer))
       (print-warning "Production compilation module not found")))


(defun recursive-find (item list)
  (if (listp list)
      (some #'(lambda (x) (recursive-find item x)) list)
    (eq item list)))


(defun rename-variables (p vars not-vars)
  (do* ((x vars (cdr x))
        (new-var (do ((new-var (new-name-fct (car x))
                               (new-name-fct (car x))))
                     ((not (find new-var not-vars)) new-var))
                 (do ((new-var (new-name-fct (car x))
                               (new-name-fct (car x))))
                     ((not (find new-var not-vars)) new-var))
                 )
        (bindings (list (cons (car x) new-var))
                  (push (cons (car x) new-var) bindings)))
       ((null (cdr x))
        (values (replace-variables p bindings) bindings))))



(defun remove-buffers (vars)
  (let ((module (get-module production-compilation)))
    (remove-if #'(lambda (x)
                   (when (find x *buffer-var-names*)
                     (let* ((buffer (intern (subseq (symbol-name x) 1)))
                            (buffer-type (get-compilation-type-struct buffer module)))
                       (comp-buffer-type-drop-out buffer-type))))
               vars)))



(defun produce-standard-representation (production)
  "This should be part of the general parsing, but for now doing after the fact
   assumes that conditions and actions aren't duplicated"
  (aif (production-standard-rep production)
       it
       (let ((parse nil)
             (lhs nil)
             (rhs nil))
         (dolist (c (production-lhs production))
           (push (list (convert-cmd (car c))
                       (case (caar c)
                         (#\= (append (list (subseq (second c) 0 2)) (sort (copy-tree (fifth c)) #'string< :key #'slot-to-string)))
                         (#\? (sort (copy-tree (append (third c) (fourth c))) #'string< :key #'slot-to-string))
                         (#\! (second c))))
                 lhs))
         (dolist (a (production-rhs production))
           (push (list (convert-cmd (car a))
                       (cond ((null (second a)) nil)
                             ((eq #\! (caar a))
                              (second a))
                             ((= (length (second a)) 1)
                              (second a))
                             ((eq (car (second a)) 'isa)
                              (append (list (subseq (second a) 0 2)) (sort (copy-tree (chunk-spec-slot-spec (define-variable-chunk-spec-fct (second a))))
                                                                           #'string< :key #'slot-to-string)))
                             (t ;; modification either = or +
                              (sort (modification-pairs (second a))
                                    #'string< :key #'slot-to-string))))
                 rhs))
         (push (sort rhs #'string< :key #'(lambda (x) (string (car x)))) parse)
         (push (sort lhs #'string< :key #'(lambda (x) (string (car x)))) parse)
         
         (setf (production-standard-rep production) parse))))

(defun slot-to-string (slot-list)  
  "Converts a list of items to a string with the gaps replaced with %%%"
  (format nil "~{~A%%%~}" slot-list))

(defun convert-cmd (cmd-cons)
  "Converts a cons of command identifier and command to the production symbol"
  (read-from-string (if (eq #\! (car cmd-cons))
                        (format nil "!~a!" (cdr cmd-cons))
                      (format nil "~c~a>" (car cmd-cons) (cdr cmd-cons)))))

(defun modification-pairs (mod-list)  
  (let ((res nil))
    (while mod-list
      (push-last (list (pop mod-list) (pop mod-list)) res))
    res))


(defun buffer+-union (a1 a2)
  (dolist (mod (second a2))
    (when (find-if #'(lambda (x)
                       (and (eq (car x) '=)
                            (eq (second x) (car mod))))
                   (second a1))
      (setf (second a1) (remove-if #'(lambda (x)
                                       (and (eq (car x) '=)
                                            (eq (second x) (car mod))))
                                   (second a1))))
    (setf (second a1) (append (second a1) (list (list '= (first mod) (second mod))))))
  a1)


(defun buffer=-union (a1 a2)
  (dolist (mod (second a2))
    (when (find (car mod) (second a1) :key #'car)
      (setf (second a1) (remove (car mod) (second a1) :key #'car)))
    (setf (second a1) (append (second a1) (list mod))))
  a1)

(defun buffer-condition-union (c1 c2 a1)
  
  (when (or c1 c2)
    (if (null c2)
        c1
      (let ((c1-type (second (caadr c1)))
            (c2-type (second (caadr c2))))
      
      ;; remove the isa test from c2
        (unless (null c1) 
          (setf (second c2) (remove 'isa (second c2) :key #'first)))
        
       ; (pprint c2)
        
        ;; First remove those elements of c2 set in a1
        (dolist (mod (second a1))
          (when (find-if #'(lambda (x)
                             (eq (second x) (car mod)))
                         (second c2))
            (setf (second c2) (remove-if #'(lambda (x)
                                             (eq (second x) (car mod)))
                                         (second c2)))))
        (if (null c1)
            c2
          ;; Add the remaining elements of c2 to c1 and set the type to the
          ;; more specific of the two
          (let ((slots (remove-duplicates (append (cdr (second c1)) (second c2)) :test #'equal)))
            (list (car c1) (append (list (list 'isa (if (chunk-type-subtype-p-fct c1-type c2-type)
                                                        c1-type
                                                      c2-type)))
                                   slots))))))))



(defun constant-value-p (val)
  (or (not (chunk-spec-variable-p val))
      (find val *buffer-var-names*)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; User commands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro specify-compilation-buffer-type (buffer-name buffer-type)
  `(specify-compilation-buffer-type-fct ',buffer-name ',buffer-type))

(defun specify-compilation-buffer-type-fct (buffer-name buffer-type)
  (let ((module (get-module production-compilation)))
    (if module
        (let ((type (gethash buffer-type *valid-compilation-buffer-types*)))
          (cond ((not (= (mp-time-ms) 0))
                 (print-warning "Cannot change a buffer's compilation type once the model has started running."))
                ((not (find buffer-name (buffers)))
                 (print-warning "No buffer named ~s found." buffer-name))
                ((not type)
                 (print-warning "Invalid compilation buffer type ~S." buffer-type))
                (t
                 (setf (gethash buffer-name 
                                (compilation-module-buffer-type-table module))
                   type)
                 t)))
      (print-warning "No production compilation module found"))))


(defun show-compilation-buffer-types ()
  (let ((module (get-module production-compilation)))
    (if module
        (let ((len (apply #'max (mapcar #'(lambda (x)
                                            (length (string x)))
                                  (buffers)))))
          (command-output "  ~va        Type" len "Buffer")
          (maphash #'(lambda (buffer type)
                       (command-output "~va        ~a" len buffer (comp-buffer-type-name type)))
                   (compilation-module-buffer-type-table module)))
      (print-warning "No production compilation module found"))))


(defmacro compilation-buffer-type (buffer-name)
  `(compilation-buffer-type-fct ',buffer-name))

(defun compilation-buffer-type-fct (buffer)
  (let ((module (get-module production-compilation)))
    (if module
        (let ((type (gethash buffer (compilation-module-buffer-type-table module))))
          (if type
              (comp-buffer-type-name type)
            nil))
      (print-warning "No production compilation module found"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Support code for converting the excel tables into files in the tools
;;; directory.
;;; Call this with a list of pathnames to tab delimited files of valid spreadsheets 
;;; that describe the types of buffer for composition to create.
;;;
;;; It will write out a file in the tools directory named {type-name}-compilation.lisp
;;; where {type-name} is the name specified for the type in the spreadsheet description.
;;;
;;; It also writes out empty definitions for the functions that need to be defined
;;; based on the specification given.
;;;
;;; For now those control functions will be passed low-level data types which aren't
;;; specified anywhere (the raw production structures, ugly list based production
;;; parses, and the compilation module instance).  Eventually, these interface functions
;;; will need to be passed something more appropriate and specified, but right now
;;; it's just a more distributed version of the current code.


(defun build-compilation-type-file (files &optional (by-dan nil))
  (dolist (file files)
    ; Since this isn't a user function it forgoes a lot of error checking
    (with-open-file (f file :direction :input)
      
      (let* (map compose consistency pre-instan buffers table drop-out whynot
              (style (read f))
              (pathname (translate-logical-pathname (format nil "ACT-R6:tools;~(~a~)-compilation.lisp" style))))
        
        (with-open-file (outfile pathname :direction :output :if-exists :overwrite :if-does-not-exist :create)
        
        (multiple-value-bind (second minute hour date month year) (decode-universal-time (get-universal-time))
          (declare (ignore hour minute second))
          
          (format outfile ";;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-~%")
          (format outfile ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;~%")
          (format outfile ";;; ~%")
          (format outfile ";;; Author      : ~[Dan Bothell~]~%" by-dan)
          (format outfile ";;; Copyright   : (c) ~d ~[Dan Bothell~]~%" year by-dan)
          (format outfile ";;; Availability: Covered by the GNU LGPL, see LGPL.txt~%")
          (format outfile ";;; Address     : ~[Department of Psychology~]~%" by-dan)
          (format outfile ";;;             : ~[Carnegie Mellon University~]~%" by-dan)
          (format outfile ";;;             : ~[Pittsburgh, PA 15213-3890~]~%" by-dan)
          (format outfile ";;;             : ~[db30@andrew.cmu.edu~]~%" by-dan)
          (format outfile ";;; ~%")
          (format outfile ";;; ~%")
          (format outfile ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;~%")
          (format outfile ";;; ~%")
          (format outfile ";;; Filename    : ~(~a~)-compilation.lisp~%" style)
          (format outfile ";;; Version     : 1.0~%")
          (format outfile ";;; ~%")
          (format outfile ";;; Description : Production compilation ~s style definition.~%" style)
          (format outfile ";;; ~%")
          (format outfile ";;; Bugs        : ~%")
          (format outfile ";;;~%")
          (format outfile ";;; To do       : ~%;;;~%")
          (format outfile ";;; ----- History -----~%")
          (format outfile ";;;~%")
          (format outfile ";;; ~d.~d.~2,'0d ~[Dan~]~%" year month date by-dan)
          (format outfile ";;;             : * Created automatically by build-compilation-type-file.~%")
          (format outfile ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;~%")
          (format outfile "~%")
          (format outfile "#+:packaged-actr (in-package :act-r)~%")
          (format outfile "#+(and :clean-actr (not :packaged-actr) :ALLEGRO-IDE) (in-package :cg-user)~%")
          (format outfile "#-(or (not :clean-actr) :packaged-actr :ALLEGRO-IDE) (in-package :cl-user)~%")

          (setf map (read f))
          (setf compose (read f))
          (setf consistency (read f))
          (setf pre-instan (read f))
          (setf drop-out (read f))
          (setf whynot (read f))
          (setf buffers (read f))
          ;; get the rest of the empty line
          (read-line f)
          ;; read the line P1 and P2
          (read-line f)
          (let ((p2-indices 
                 (do* ((l nil)
                       (s (make-string-input-stream (read-line f)))
                       (val (read s nil nil) (read s nil nil)))
                      ((null val) (reverse l))
                   (push val l))))
            (read-line f)
            (dotimes (i (length p2-indices))
              (let ((p1-index (read f)))
                (read f)
                (dotimes (j (length p2-indices))
                  (awhen (read f)
                         (push (list p1-index (nth j p2-indices) it) table))))))
          
          (format outfile "~%")
          (format outfile "~%")
          
          ;; Write out the stubs for the functions specified
          (when map
            (format outfile "(defun ~a (module p1 p1-s p2 p2-s buffer)~%)~%" map))
          (when compose 
            (format outfile "(defun ~a (p1 p1-s p2 p2-s buffer)~%)~%" compose))
          (when consistency 
            (format outfile "(defun ~a (buffer module p1 p2)~%)~%" consistency))
          (when pre-instan 
            (format outfile "(defun ~a (buffer-and-index p2)~%)~%" pre-instan))
          (when whynot 
            (format outfile "(defun ~a (p1-index p2-index failed-function)~%)~%" whynot))
          
          ;; write stubs for any functions in the table
          
          (let (done)
            (dolist (x table)
              (when (and (third x) (not (eq (third x) t)) (not (find (third x) done)))
                (format outfile "(defun ~a (buffer p1 p2)~%)~%" (third x))
                (push (third x) done))))
          
          ;; Write the buffer definition itself
          
          (format outfile "~%(define-compilation-type ~a ~a ~s ~a ~a ~a ~a ~a ~a)~%~%"
            style table buffers map compose consistency pre-instan drop-out whynot)
          
          (format outfile "#|~%")
          (format outfile "This library is free software; you can redistribute it and/or~%")
          (format outfile "modify it under the terms of the GNU Lesser General Public~%")
          (format outfile "License as published by the Free Software Foundation; either~%")
          (format outfile "version 2.1 of the License, or (at your option) any later version.~%")
          (format outfile "~%")
          (format outfile "This library is distributed in the hope that it will be useful,~%")
          (format outfile "but WITHOUT ANY WARRANTY; without even the implied warranty of~%")
          (format outfile "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU~%")
          (format outfile "Lesser General Public License for more details.~%")
          (format outfile "~%")
          (format outfile "You should have received a copy of the GNU Lesser General Public~%")
          (format outfile "License along with this library; if not, write to the Free Software~%")
          (format outfile "Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA~%")
          (format outfile "|#~%")))))))


#|
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
|#
              
